변수, 함수를 정의하는 파일
etc/profile.d/	2
/etc/profile	1
~/.profile	3

모든 사용자가 공통적으로 받게되는
------------
/etc/bashrc	6
~/bashrc	5
~/.bash_profile	4	

로그인 쉘, 로그인 할 때 기본적으로 적용 되어있는 쉘 (따로 지정을 하지 않으면, 기본으로 사용한다.)
어떤 사용자가 로그인 쉘을 z쉘을 사용하면 위에 3개의 쉘은 적용되지만 아래 쉘은 적용되지 않는다.

etc디렉토리, home 
etc디렉토리에 있는 건 모든 사용자가 공통적으로 받는다. / 대부분 수정하지 않음. 전체적으로 영향을 받는다
home디렉토리는 특정 사용자만 받는다. (home 디렉토리는 다른 사용자는 사용 할 수 없다.)
 나만 쓸 설정이 필요하다 = home 디렉토리에서 설정한다.

보통 서버는 혼자서 관리하는 일은 드물다. / 여러 사람이 접근이 가능하다.
개인적 선호 설정은 개인만 해야지. 다른 사용자에게 그 영향이 미치면 안된다.

거의 대부분 홈 디렉토리에 있는 것을 적용하는게 일반적이다.

적용되는 순서가 있다. / 순서를 알아야된다.
똑같은 변수가 있는데. A라는 변수가 모든 파일에 있다고 생각해보자. A의 값은 다 다르다.
최종적으로 어디에 있는 파일에 A의 값이 될까? -> 제일 마지막
마지막에 읽는게 우선순위가 제일 높다.

Profile은 쉘에 상관없이 모든 사용자가 받게된다.
bashrc,등은 bash 사용자만 받을 수 있다 / bash쉘에서만 사용 할 수 있는 기능만 넣어줘야한다.
etc는 모든 사용자	/	home은 특정 사용자


sh : bourne shell

bin과 usr/bin 관계는 어떤가?
 심볼릭링크, 둘은 같다.

리눅스에서 사용 할 수 있는 쉘은 4가지이다.
bourne shell
bash shell
tshell
chell

환경변수 파일, 환경설정 파일
환경을 설정한다. 설정 할때 변수를 선언을 한다.
어떤 특정 변수는 시스템을 사용함에 따라서 시스템 환경에 영향을 미친다. / 시스템의 환경변수라고 한다.

env : 시스템에 등록 되어있는 변수 / 운영체제가 사용하는 변수 (운영체제의 환경설정을 위한 변수)
 -u 변수를 해제한다
변수의 이름은 대문자로 되어있다. 왼쪽은 이름 / 오른쪽은 거기에 대한 값이다.

user 로그인된 사용자, 히스토리 사이즈, ls color

set : 쉘이 사용하는 변수 / export를 시키면 os가 사용하는 환경변수가 된다.
 unset 변수 : 변수를 해제한다.

export : 내보내기 / 다른 쉘에서 사용 할 수 있도록 내보낸다. / 변수를 export 하게 되면 운영체제에서 사용이 가능하다. = 다른 쉘에서도 사용 할 수 있다. / 환경변수로 내보내기 한 변수이다.
 declare = 선언한다. 이 변수를 운영체제가 사용 할 수 있게 선언한다.

변수들은 시스템에 영향을 주게 된다.
변수마다 조작이 가능이 가능한 변수가 있다. / ex PS1
변수를 조정을 하게되면 시스템 동작에 영향을 줄 수 있다.

echo $PATH
path의 환경 변수 값을 날리면 

path 환경변수
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
path라고 하는 변수의 값, 명령어의 위치를 지정한다. / 디렉토리 8개가 지정되어있다.
기본적으로 명령어를 찾는 위치이다. ls 명령어를 사용 할 때 현재 디렉토리에 없다. 실행파일이
즉 시스템은 자동으로 path의 순서대로 찾게된다.

which ls : 명령어에 대한 위치가 나온다.

명령어를 실행하는 방법 2가지 절대경로, 상대경로가 있다.
path 변수의 도움을 받아서 명령어만 치더라도

보통은 명령어를 심볼릭 링크를 걸어둔다. / 모든 사용자가 사용할꺼면 /etc | 개인만 사용하려면 /home 밑에 링크를건다.

해당 명령어가 있는 위치를 path 변수에 하나 더 넣어준다.

보통 일반적으로 환경설정을 할 때 여러가지가 있는데, 
보통 Ps1 변수, path 변수는 개인적으로 선호하는 방식으로 설정을 한다.

PS1 generator
시스템을 효율적으로 관리 할 수 있다. / 자신만의 방식으로 구현 할 수 있다.

여러가지 운영체제가 사용 변수/ 쉘이 사용하는 변수
ps1, path : 쉘이 사용하는 변수
어플리케이션을 만들든 외부 어플리케이션을 가지고 왔을 때 요구 하는 변수가 있다 -> 어플리케이션 변수

거의 대부분 모양, 설정을 하는 것 / 프로그래밍을 하는 경우는 드물지만, 개념은 알고 있어야한다.

.bashrc 대부분 이용한다. 이 파일이 홈 디렉토리에 있는 가장 마지막 파일이므로 여기에 설정한다.
ps1 변수
alias (별칭) : 쉘에 따라 있는 경우도 있고 없는경우도 있다. / 긴 명령어, 자주사용하는 옵션을 지정 가능하다.
재부팅, 다른 쉘 가면 없어진다. -- bashrc에 넣어두면 된다.

vi랑 vim이랑 명령어가 따로있다.

login shell : 로그인이 되었을 때 쉘 실행
non-login shell : 로그인이 되지 않았을 때도 쉘 실행 (비로그인 방식)

bash_profile - 로그인 했을 때만 읽게되는 파일이다. / 로그아웃을 했다가 로그인을 해야한다. / 비로그인쉘을 하면 안읽는다.
. ./.bashrc : bashrc를 실행해라 = source .bashrc

보통 블로그에선 재부팅하라고 하는데, 제대로 알고 해야한다.
데스크탑이야 재부팅 하면 되는데, 서버는 재부팅하면 안된다.

명령어, 반복문, 조건문 다 쉘 스크립트이다.
시스템 부팅 했을 때, 로그인 했을 때, 쉘 띄웠을 때 자동으로 읽어서 실행한다.

여기 있는 파일 전체가 뭐냐? -> 쉘 스크립트 파일이다.


CHAPTER 7 퍼미션

Identification :
식별 / 흔히 말하는 ID
일반적으로 시스템에는 계정 ACOUNT, USER, ID 다 같은 의미이다.

Authentication :
인증 / ID를 갖고 있는 사람이 맞는지 확인하는 작업
여러가지 방식이 있다. / 가장 일반적으로 사용하는 방식이 Password이다.
고급지게 얘기하면 지식기반의 인증. / password를 알고 있어야한다.
다르게 얘기하면 소유기반의 인증. / 생체인식 | 지문인식, 얼굴인식 등
요즘은 멀티팩트 인증 / 투팩트 인증 // 여러가지를 섞어쓴다.
password는 가장 낮은 기반의 인증 - 노출 되기가 쉽다.

Credertial :
자격증명 / 자격을 증명하는 방식이 password냐, 생체인식 인증이냐 등

authorization :
권한부여 & 인가 / 인증을 받게되면 식별이 가능한 ID기준으로 정책을 만들어놓는데
이런 정책들은 크게 두 가지로 나뉘어진다.

privlage(특권) / Rights(권한)
What to do? 액션
시스템을 끌 수 있느냐? / 시간을 바꿀 수 있느냐 등 액션의 개념
user란 사용자가 운영체제를 설치할 때 관리자 권한을 
일반 사용자는 원래 컴퓨터를 끌 수 없다. / 일반 사용자는 권한이 없다.

명령어를 사용하는거랑 시스템을 실제로 끌 수 있는거랑 아무 상관이 없다.
명령어를 실행 할 수 있어도 컴퓨터를 끌 수 없을 수 있다.

뭔가 할 수 있느냐 없느냐 액션을 취하는 걸 허용 하는 것. / 행동에 제한이 걸려있다.

Permission(권한)
How /what to use? 사용

오브젝트 파일을 사용 할 수 있느냐 없느냐의 개념.

운영체제 접근 방식은 3가지

DAC : 임의적 접근제어
RBAC : 역할기반의 접근제어
MAC : 강제적 접근제어

상업적인 운영체제 = 우리가 사용하는 모든 운영체제 = DAC를 사용한다.
치명적인 문제가 있다. - 관리자라는 녀석이 모든 특권을 다 가지고 있다.
일반 사용자는 모든 액션이 제한이 걸려 있지만, 관리자는 모두 다 가능한 형태
퍼미션보다 privlage가 더 큰 권한 / root는 퍼미션에 제약을 받지 않는다 = 신, super user
관리자 계정에 문제가 생기면 게임 끝

가장 기본적인 형태를 안 지키면 보안에 문제가 생긴다.

-		rw-		r--		r--
File Type	user		group		other

r = reaable 읽기
w = writeable 쓰기
x = executable 실행
- = denied

소유자 -> 그룹 -> 기타사용자로 우선순위가 있으며,

사용자는 무조건 하나의 그룹에 속해야한다.
같은 사용자라면 소유자 비교를 해서 접근제어,
그룹, 소유 그룹 접근제어,
나머지는 기타 사용자로 접근제어를 받는다.

파일 퍼미션
읽기 r : 파일의 내용을 확인하거나 복사 할 수 있습니다. / cat, vi, mv, cp 등

쓰기 w : 파일의 내용을 수정할 수 있습니다. / 권한이 없으면 파일 생성이 안되고, 만드는 개념, 저장이 안된다.

실행 x : 실행파일의 경우 실행할 수 있습니다. 쉘 스크립트 파일의 경우 읽기와 실행 퍼미션을 가지고 있다면 실행 할 수 있습니다.

읽기와 실행은 짝으로 묶어서 사용한다. => 쓰기 권한도 필요할까? => 악성코드를 넣을 수 있게 되서 안된다.

Language는 compile, script로 나뉘는데,
compile (exe,elf) | script (shell) 실행권한 x 읽기만한다. 필요에 따라 바뀔 수 있다.
스크립트는 바로 실행이 가능하다. 하지만 직접스크립트는 실행권한을 줘야한다.

디렉토리 퍼미션
디렉토리는 파일의 목록을 갖고 있다고 할 수 있다.

읽기 r : ls 명령어를 이용하여 디렉토리 내용을 확인 할 수 있다.

쓰기 w : 실행권한이 있을 경우 디렉토리 내에 파일을 추가하거나 삭제할 수 있다.
 디렉토리 쓰기 권한이 없으면 파일에 권한이 있어도 디렉토리에 대한 권한이 없으므로 파일 추가, 삭제가 불가능하다.

실행 x : cd 명령어를 이용하여 디렉토리 접근 할 수 있다 / 읽기 권한이 있다면 ls-l로 디렉토리 내용 확인이 가능함
 읽기권한이 없다면, 접속은 가능한데 못 본다.

보통 아주 특수한 목적이 없다면 읽기, 실행 권한에 대한 퍼미션을 준다.
디렉토리는 파일명과 inode과 매핑이 되어있다 = 하드링크이다.

Least privilege : 최소한의 권한 / 데이터 및 기능 오류, 악의적인 동작 (컴퓨터보안)을 하기 위함이다.

Fc (full control) : rwx 모두 권한이 있는 상태를 fc 라고 한다.

ls -n :
UID(user in-denfitication number) / GID(group identification number) 
소유자의 정보 ID를 확인하기 위한 명령어

UID=UID YES -> User user permissions		소유자
NO -> GID=GID YES -> User group permissions	그룹
NO -> User other permissions			기타사용자

순서대로 비교해서 UID, GID 불일치시 기타 사용자 권한으로 퍼미션에 따라 접근권한이 주어진다.

퍼미션모드는 심볼릭 모드와 8진수 모드로 나누어지는데, 편한 방식으로 사용하면된다.

심볼릭 모드의 변경

$ chmod		mode		filename
	who	op	permission(s)

who - u : 소유자	g : 그룹	o : 기타	a : 모든 사용자
op - + : 퍼미션 추가	- : 퍼미션 삭제	= : 퍼미션 추가
permission - r : Read	w : Write	x : Execute // 안 주는 것은 거부

Unix 기본 퍼미션 설정 :
Diretory 777
file 666

umask로 deflut값이 조정된다.
user 002	/	root 022

관리자 생성파일은 뭐든 그룹에 권한을 주지 않는다. (필요에 따라 조절가능)
bash 지정 기본 값

서버는 보통 027으로 defult값을 정해놓는다. / 기타 사용자 x

Unix 커널은 
user ID = 0 = 관리자 (root) / unix는 보통 0이 관리자이다.
windows는 administrator group = 관리자 / 윈도우는 admin 그룹에 속해있다면, 관리자가 된다.

CPU 소켓의 종류
1151v2
2066
소켓이 다르면 연결 할 수 없어서 못 끼운다.

AMD는 소켓을 한번 정하면 잘 안바꾼다.		업그레이드 용이
Intel은 새로운 CPU가 나올 때 마다 소켓을 바꾼다	업그레이드 x

인텔 제온
서버용 CPU
성능이 같더라도 서버용은 가격이 더 비싸다.
2011-v3

context switching
바꿔가면서 동시에 하는 거 처럼 사기치는라는 형식이라고 한다.

소켓타입은 nm로 선이 얇을수록 열이 적게 나고 전기를 덜 먹는다.
현재는 너무 작아 엄청 좋은 현미경으로 봐야 보인다고 한다.

자동차가 수냉쿨러를 사용하듯이 서버도 수냉쿨러를 사용한다.
자연을 이용해서 바다에 데이터센터를 설치한다던지, 산같은 고지대에 설치해서 CPU온도를 줄이기도한다.
cpu 80도가 넘어가면 타니까 온도 관리를 해줘야한다.

CPU 캐시
 메모리보다 더 빠른 저장공간
 명령어를 처리하기 바로 전에 임시로 저장한다.
 용량이 보통 작은편인데, 서버용은 데스크탑용보다 조금 더 크다. (약 30mb)

하이퍼스레딩 :
하나의 코어에 쓰레드가 2개 (인텔) / 멀티쓰레드

보통 1코어 2쓰레드
파워 CPU는 1코어 8개 16개 32개 / 쓰레드

인텔 취약점 이슈
쓰레드가 독자적으로 동작해야하는데, 서로 영향을 미친다.
아무것도 아닌 프로그램을 갖고 루트권한을 취득 할 수 있다.
과거에 생산된 cpu에서는 하이퍼스레드 기술을 끄라고한다. / 그러면 스레드의 기능 이유가 없지않나?
서버 CPU를 전 세계에서 인텔을 사용하는데, 보상을 하게 되면, 인텔은 파산 할 것이다.

lscpu - cpu정보를 볼 수 있는 명령어

program : disk에 있는 실행 프로그램
process : memory에 있는 실행프로그램이 올라감.

1 process - 1 thread
개발자가 프로그래밍할 때 멀티 프로세싱을 할 수 있다.
하나의 프로그램이 실행만 하면 프로세스가 여러 개 뜰 수 있는거다.

멀티프로세스 프로그램도 있고, 멀티스레드 프로그램도 있다.

멀티스레드 프로그램 단점은
CPU에 물리적 스레드가 많지 않으면 논리적 스레드가 많을 때
병목 현상이 발생할 수 있어서, 성능저하가 올 수 있다.

제일 꼭대기 커널 = 스케줄러 / 모든 프로세스를 조정
프로세스의 이름은 실행하는 이름이다.

terminal이 bash를 실행시키고 bash가 ls를 실행시킨다
termianl은 bash의 부모프로세스 bash는 ls의 부모프로세스라고 볼 수 있다.


          fork()
		wait------->실행
부모--------------------------------
	|		|
	|		| exit
자식	-----------------

































