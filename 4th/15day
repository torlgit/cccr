lto tape : 테이프, 컴퓨터에 연결해서 요즘에도 사용 / 클라우드에서도 쓴다.
cd rom, hard disk 처럼 연결한다. rack과 연결을 한다.


lto tape : 테이프, 컴퓨터나 Rack에 연결해서 요즘에도 사용을 한다.	/ 클라우드에서도 장비로 쓴다.
회사에서 cd rom, hard disk 처럼 연결해서 사용한다. / 테이프 하나의 30TB 저장이 가능하다.
재작년, 작년 기준으로 판매한 용량을 계산해봤는데, 10 Petabyte 가 나왔다고한다.
초 당 1테라 정도의 전송이 가능하다고 한다.

요즘 추세는 lto tape보다는 디스크를 더 많이 사용한다.

Archive : cold data를 저장하기 위한 방법
Backup : 말 그대로 백업

요즘은 아카이브나, 백업을 디스크에 하는 경우가 많다.
옛날에는 테이프도 표준이 많았지만, 현재는 lto 표준만이 남아있다.

기본적으로 디스크가 빠르다. lto 방식도 초 당 900기가 전송이 가능하다.
중요한건 디스크가 더 빠르고 그 다음에 테입의 가장 큰 단점은 Random access이다

Read
Random Acess
Seguemce Access

데이터가 연속적으로 배치 되어 있을수도 있고, 아닐수도 있다.
테입을 물리적으로 감아야한다. 디스크는 데스크탑 경우로 분당 7200번 돈다.
서버 같은 경우는 분당 12000번 돈다
테이프 같은 경우는 랜덤액세스가 느리다.
테이프보다는 랜덤엑세스가 빠르지만, ssd보다 느리다 (하드디스크의 큰 단점은 랜덤엑세스)
ssd는 반도체이므로 흩어져있든 뭉쳐있든 상관이 없다.

테이프 같은 경우는 랜덤엑세스가 상당히 좋지않다.
하드디스크는 물리적인 충격에 약하다.


왜 아직 테이프를 쓸까?
-> 보관이 용이하고, 디스크보다 데이터의 수명이 길다. ssd < hard < tape 순 가격이 싸다.

online Hot Data
offline cold data 

우리 기준으로 hot data는 하드 디스크, cold data는 외장하드로 비유 할 수 있다.
스토리지에서 계속해서 쓰고 변경하고 해야하기 때문에, 
로그 같은 경우는 법적으로 얼마정도는 보관해야한다.
문제가 생겼을 때 봐야하는 데이터이다, 그 외에는 필요가 없는 데이터

cold data를 저장하기 위해서 보관용으로 사용한다.


아카이브

아카이브와 압축을 동시에 지원을 한다. 여러가지 포맷들이 아카이브와 압축을 동시에 지원하는 경우도 있고, 아닌 경우도 있다.

zip도 실제로 그렇게 만들어서 압축을 한다.

unix에서는 tar로 한다.
데이터를 묶기 위한 목적으로 사용

tar :


jar :
자바 아카이브, 자바 프로그램을 압축할 때 사용한다. 기본적으로 tar의 아카이브에 더해서 zip으로 자동 압축한다.

tar, jar은 비슷하면서 다르다. 옵션은 100% 똑같다.
차이점은 목적이 다르다.

생성	cf a.tar
확인	tf a.tar
풀기	xf a.tar

f뒤에는 파일명이 와야한다.













데이터 프로토콜들은 암호화를 한다.
우리가 사용하는 인터넷이라는 공간은 다 같이 사용을 한다. = 누구든지 엿 볼수가 있다.
ID, PW, EMAILL / 인터넷에서 왔다갔다 하는 데이터들은 도감청이 가능하다.
몇 년전 에드워드
프리즘 프로젝트 : 전 세계 네트워크를 도감청한다.
우리나라도 합법적으로 다 도감청한다. 어떤 걸 검색하는지, 뭘 하는지.. 다 알 수 있다. -> 그래서 암호화를 한다.
ete (end to end) : 암호화.

학문, 암호학이라고 한다. / IT의 계열이 아니라 수학의 영역이다.
기본적으로 일반적인 메시지를 얼마나 알 수 없게 복잡하게 만드는거에 대한 알고리즘 = 암호화방식 / 수학이다.
암호화를 제대로 얘기하려면 수학을 얘기해야한다.

암호화 : 암호화가 정해주는 기능은 4가지이다.
기밀성(confidential) 적법하지 않은 사용자가 데이터를 접근 할 수 없게, 데이터 접근을 하더라도 알 수 없게 하는 것

무결성(Integrity) 허가되지 않은 사용자가 허가 받은 사용자만 데이터를 조작 할 수 있는 것

인증 Authertiation 

부인방지(Non-repudiation) 부인을 하는 것을 방지 / 
계약서에 서명, 날인을 하는 걸 왜 하는지? -> 나중에 딴 소리 못하게 하려고
IT에서는 전자서명이 있다.

필요할 때 언제든지 사용 할 수 있는 것 가용성

공인인증서 : 인증서라는게 KEY인데, 이걸 사용자한테 관리를 하라고 하고, 거기에 대한 책임을 안진다. (이슈)
 위의 4가지에 해당한다.

4가지의 정의를 알고 있어야한다

보안 3 요소
C 
I
Availability

우리가 봐야하는건 크게 3가지
synmetric key : 많이 쓴다. 대칭이라는 의미 즉, 암호를 하는 사람과 복호화 (기밀성만 제공)
메시지를 암호화를 하는 것 (인크립션) 메시지를 원래대로 되돌리는걸 복호화 
asynmtric key : 비대칭 / 퍼블릭키 암호화 시스템 (기밀성, 인증, 부인방지 제공)
hash fuction : 해쉬 알고리즘, 줄여서 해쉬라고도 한다. (무결성만 제공) / 암호화는 아니지만 암호화 학문에서 다룬다 -> 왜 암호화가 아니냐? -> 키가 없다. 대칭이든 아니든 키가 있어야한다. 
엄밀하게 말하면 암호화라고 할 수 없지만 암호화와 같이 설명된다.

적절하게 섞어써야 4가지를 모두 다 적용 할 수 있다.

무결성 :
Ethernet frame 어떻게 생겼나? [L2H | Payload | L2F] Trailor / footer. <- cheak sum = 오류검출

오류검출이 뭐냐 ? -> 무결성

A -> B 데이터 전송 HEADER , Payload를 보내고  xor연산으로 L2F을 A가 만든다.
B가 받아서 xor연산으로 L2F를 푸는데 값이 다르면, 문제가 있다. (무결성이 깨진거다)

A -> B
데이터 전송 할 때 Header, Payload를 보내고 

IP Header, Tcp Header
cheack sum fild가 있다. 같으면 상관없지만, 다르면 문제가 있다.

ICMP type 12 : Ip header cheak sum error / 이 오류가 발생하면 Ip header에 문제가 있는거다.

Hash funbction
    algorithm
message digst
one way function







encrypt
decrypt
palintest 평문 (encrypt = 암호화
cyphertext 암호문 (deaypt + sy 복호화)
cryptography
cryptology

암호학 관련 책 한 권 이상은 읽어보는게 좋다.

Rot13 (rotate) 시저 암호, 13자리를 미는 것 [13이라는게 key다] / shift 시킨다. <알고리즘>

Confusion 혼돈 / 잘 알아보지 못하게 혼돈 시킨다.
diffusion 확산 / 알아보지 못하게 얼마나 확산 시키나.

substitution 치환 / 문자를 바꾸는 것
transposition 전치 / 위치를 바꾸는 것

수학적으로 얼마나 치환, 전치가 잘 일어나느냐 -> 암호화가 잘된것

Rounds : 알고리즘을 몇 번 돌리나? 혼돈과 확산을 한번의 Rounds 한다. / 혼돈과 확산을 계속 만들어낸다.

부호화 / 인코딩 
복호화 / 디코딩

암호화가 아니다. 데이터를 잘 저장하고 잘 전달하기 위해서 코드로 나타낸다

인코딩 방식 중에 base64 이 있다.

protocol에 어떤 특정 값을 부호화하는 경우가 있는데, 보통 http 프로토콜에서 많이 사용하는데,
왜 하느냐?? -> 알아보기 어렵게 하려고 // 간혹 사용한다. 알아보는 사람한테는 효과가 없다.

인코딩, 디코딩이기 때문에 쉽게 풀어낼 수 있다.


대칭 키
	  alice				   bob
	plaintext			plaintext
	    ↓   				     ↑
 key →	algoithm			algoithm ← key
	    ↓				     ↑
	ciphertext	  →		cipertext

대칭키의 문제는 키를 안전하게 분배할 방법이 없다.
암호화키와 복호화키가 동일하다.
네트워크에서 쓰진 않는다.	/	쓰는 이유 - 빠르다. 비대칭 방식은 너무 느려서 못쓴다.
key = secret key / private key

DES 암호화 알고리즘 이름	IBM이 70년도에 만들었다. 90년대 키가 유출이 됐다.
3DES 별거 없다 DES를 3번 돌리는건데, 어처피 취약점이 있기에 3번을 돌리든 만 번을 돌리든 같다.
AES (표준키) 128~256bit / 키를 512 ~ 1024 늘릴 수 있는데, 지금 256을 많이 써서 256까지 사용한다.

윈도우 95, 98 영문윈도우, 비영문윈도우가 달랐다.
영문윈도우는 암호화 방식을 64bit을 사용했고
비영문은 암호화 방식을 48~56 bit를 만들어서 판매했다.
-> 패권을 가지고 싶어서, 어쩔 수 없이 법에 의해서 바뀌었다.

우리나라가 128bit 키를 전 세계 3번째로 만들었다 -> 지금은 안쓴다 AES 쓴다.
SEED(공인인증서) , ARIA, HAS-160 X

DH
Diffe	-	Hellman
대칭키의 키를 교환하는 형태로만 썼다. / 키 교환만 한다. -> 속도가 빠르기 때문에
key pair : 비대칭키 방식은 키에 쌍이 존재해야한다.
RSA : 공개키의 표준화 (1024-2048bit)	/	산업표준
ECC : 타원곡선알고리즘을 통해서 구현을 한 공개키 (256-512bit)

public key :
누구에게나 공개해도 상관이 없는 키

개인키 :
반드시 나만 갖고 있어야 되는 키

alice - 공개키		bob - 공개키
      - 개인키/사설키	    - 개인키

대칭키 방식의 문제점
-> 사용자가 많아지면 키 개수가 많아진다. 	n(n-1)
		       			  2


	  alice				   bob
	plaintext			plaintext
	    ↓   				     ↑
bob공키→algoithm			algoithm ← bob개인키
	    ↓				     ↑
	ciphertext	  →		cipertext
			  C

기밀성 : 공개키로 암호화를 하면 개인키로만 복호화 할 수 있다.
	개인키로 암호화를 하면 공개키로만 복호화 할 수 있다.

키를 안전하게 보낼 수 없던 걸 안전하게 보낼 수 있게 되었다.
개인키가 외부에 노출이 되지 않는다면, 절대로 풀 수 있는 방법이없다. / 속도가 엄청나게 느리다.

A의 개인키로 cihpertext를 했을 때 C가 전달된 정보를 도청 및 조작한 후 다른 쪽으로 전달한다.

전자서명 알고리즘 : 공개키 방식과 해시를 섞어서 같이 사용한다.
 RSA SHA1 - 알고리즘

A : Hello , bob -> message -> hash f(x) -> hash value (서명) -> 알고리즘 A의 개인키로 암호화 -> 전송
B : 암호 -> A의 공개키 -> hash value (서명) -> hash value -> hash f(x)

plaintext를 암호화를 해도 법으로 문제가 없다. B의 공개키로 암호화해서 보내면된다.

	  alice				   bob
	Hello bob,			hash f(x)
	    ↓   				     ↑
	hash value(서명)		hash value
	    ↓				     ↑
     A(개)알고리즘	  		알고리즘 A(공)
	    ↓		  		     ↑
	 암호화		     →		암호화	

MITM 중간자 공격
모든 암호화는 중간자 공격에 취약하다. -> public key infrastructure (PKI) - 인증서X.509
인증서 안에는 공개키, 서명, 지문(fingerprint) 제 3자의 서명 - CA(인증기관)
공개키를 hash를 뜨면 - hash value가 지문이다.
인증기관은 여러 개가 있을 수 있는데 그 중 최상위 인증기간을 Root CA라고 한다.
Root CA에는 정부기관으로, 한국인터넷진흥원이 한국의 Root CA이다
RA 등록기관 -> user (사용자) / 등록을 하면 특정기관으로부터 인증서와 개인키를 준다.
국내에는 6개의 CA가 있다. 은행이 CA로부터 인증을 받아준다.
인증서에 관련된걸 관리하는 서버를 LDAP이라고 한다.
인증서에는 개인키가 없다. 공개키를 가지고 암호화를 한다.


https = http + tls
ssl = netscape 사용하지 않는다. 개인회사 이므로 조작을 할 수 있다. (상징성으로 남아있다)
tls = pki,

인터넷 뱅킹은 양방향 인증이다. 서버와 사용자가 서로 인증
인터넷을 할 때 인증된 서버인지 사용자가 판별을 하고 접속을 한다. 단방향 인증

fqdn 기본적으로 인증서는 서버 한 대당 한개의 인증을 받아야한다.

EV-SSL 확장, 검증 / 별도의 기능은 아니다.
