r commnad
rsh
rcp
인증을 하지 않는다. / 인증이 없으니 사용하지 않는다.

telnet 23
원격컴퓨터에 접속하는 프로토콜이자 서비스. 패킷을 암호화하지 않는 단점을 갖고있다. 그래서 사용안한다.
패킷을 확인하면 ID PW가 다 보인다.

ssh 22
일반적으로 많이 쓰는게 open ssh (
유닉스, 리눅스, 맥은 open ssh를 사용한다.
요즘에 나오는 모든 unix system은 open ssh가 기본적 서버로 작동되어있다.
서버라는건 클라이언트가 인증을 하면 접속할 수 있다.

ssh는 scp sftp를 지원한다. 시큐어 카피, 시큐어 ftp
원격 컴퓨터를 할 때 unix 계열은 ssh를 사용한다.

최근에 나온 윈도우는 ssh 서버 기능을 킬 수 있다. / 우린 윈도우 안씀


암호화 방식
RSA 공개키 표준(전자서명 된다)
DSA 디지털 시그니처 알고리즘(전자서명 된다)

설정하지 않는 이상 RSA가 기본방식이다.

ss -tnap
4계층의 정보를 본다.
t는 tcp, a는 all tcp의 모든 상태정보를 보는 명령어
u는 udp, p는 process, n은 프로토콜 넘버, l은 리슨
*= 모든 ipv4	::=ipv6

서버는 비표준 포트를 사용할 수 있다.
웹서버를 하는데 80포트를 아닌 다른 포트를 사용할 수 있다.
비표준 포트를 사용하면 표기가 제대로 안된다.

/etc/ssh
ssh_host_ecdsa_key = 공개키	/	ssh_host_ecdsa_key.pub = 암호키
ssh_host_rsa_key - ssh 공개키	/	ssh_host_rsa_key-pub - ssh 암호키

ssh-keygen -lf [key]    *

절대적으로 프라이빗키는 기타사용자한테 권한을 주면 안된다.
공개키는 누구든지 읽을 수 있는 권한이 있어도된다.
키가 쌍으로 존재한다.
ssh 클라이언트가 이 서버에 접근을 할 때 rsa 알고리즘을 사용하면 rsa 공개키를 요구
상대방의 공개키를 요구하고 서버는 자신의 암호키로 해독

기본값 ECDSA, fingerprint = 지문
내가 셀프로 확인을 해야한다.
어떻게 검증을 하나??

클라이언트 측에서 미리 얘기 해준 공개키를 알고 검증을 해야한다.

중요한건 ssh는 pki *인증서 구조가 없다. 제 3자 ca가 검증을 해주지 않아서
셀프로 검증을 해야한다. 공개키의 지문을 비교한다.

.ssh
known_hosts : 상대방의 공개키가 저장이된다.
다음번에 접속을 하면 자동으로 .ssh에 확인을한다.
접속을 한번이라도 했으면 계속 쌓인다.

만약에 서버에서 키를 바꿨다면??      /       접속안된다. 키를 바꿨으니까.
서버쪽에서 클라이언트한테 키를 바꿨다면 알려줘야한다.   /       클라이언트는 그러면 known_hosts를 삭제해야한다.
키는 한번씩 주기적으로 바꿔주는게 좋다.

클라이언트가 접속 요청을 한다
서버는 클라이언트에 공개 키 전송 (키를 받아서 화면에 나오는건 내가 계산한거)
비교를해서 yes를 하면
클라이언트는 비밀키, 시크릿키 (대칭키) 생성을하고 공개키로 암호화해서 전송을하고
상대방도 복호화해서 저장을하고 통신을 하게 된다.

ssh 명령어
계정명@ip
계정을 지정을 안하는 경우 (ip만 썼다) 현재 내가 로그인된 계정으로 접속을 시도한다.
만약에 서버에 user라는 계정이 없다면 로그인이 안된다. | 내 계정이 아니다.

ssh localhost = 내가 나한테 접속을 한다.  | 내 핑거프린트이다.
처음접속을하면 핑거프린터를 물어본다.

ssh [서버 ip] [명령어]
서버로 명령어를 실행한다.  |       원격으로 명령어를 실행한다.

X11 포워딩 :
gui를 땡겨오는거 서버에서 실행하고 화면만 나에게 띄운다. /       서버도 gui가 있어야한다.
엄밀하게 말하면 나만 있어도된다.      /       일반적으로는 서버와 클라이언트 둘 다 있어야한다.

non-hosts가 언제 생성이 되는건지...
패스워드 인증 방식이다.

ed25519 ECC + DSA 한 차 세대 알고리즘, 아직은 잘 안쓴다.

클라이언트가 어떤 알고리즘으로 접속 하는지 모르니까 다 만들어놓는다
sshd_config (서버설정) / 모든 유닉스들은 자신이 클라이언트이자 서버이다.

sshd 바꾸고 서비스를 재시작하면 바뀔 수 있다.
서비스는 컴퓨터의 모든 인터페이스를 서비스를 다 한다.
네트워크 카드가 10장이 있다.. 그러면 그 10장을 모두 다 서비스를 해주는데 이렇게 되면 안된다.

ListenAddress : 

ssh_config 클라이언트 설정

hostkey를 수정해서 원하는 키방식으로 통신할 수 있다.
알고리즘이 틀려도 접속이 안된다.
ecdsa key를 제거를 해

서버는 보통 클라이언트가 어떤 알고리즘으로 접속할지 대부분 필요한 형태를 제공 해줘야한다

syslogfacility 
loglevel

permitrootlogin : 실제 서버는 루트로 로그인을 못하게 되어있다. / 일반사용자 로그인 후 sudo 명령어를 사용

passwordauthentication : password, key 기반 인증을 제공한다 (no를 하면 키 기반 인증)

permitemptypasswords : 패스워드 없는 계정 허용 (절대 하면 안된다)

ssh 키를 바꿔야 하는 경우 키파일을 지우고 서비스를 재시작하면 키파일은 생성이 된다.

인증 중에 제일 약한게 패스워드 인증이다.
중요한건 클라이언트가 키를 가지고 있어야한다. (자신의 키 쌍을 가지고 있어야하고 내 공개키를 서버에 등록을 해야한다.)     내가 접속하기 위해서 암호키를 보내면 등록된 공개키를 보고 확인을 한다.
non hosts는 서버에 있는 키를 저장하는 방식

ssh-keygen
        -t : 키 쌍의 알고리즘을 지정할 수 있다.       / rsa, ecdsa,   
기본으로 디렉토리를 지정해줘야한다. 안그러면 매번 인증할 때마다 키를 찾아야한다.

passpherase : 단락/ 문장을 써도된다. | 길어도 되는 패스워드를 말한다.
암호가 없는 방식은 안 좋은 방식이다. (실제로는 암호를 입력해야한다)

절대로 프라이빗키는 기타사용자 권한을 주면 안된다. (홈디렉토리는 루트가 아니면 아무도 접근 못한다)
복사 / 쓰기 권한도 나밖에 없다. (defult 값이긴하다)

키를 만들면 서버에 등록해야한다. -> ssh-copy-id user@192.168.56.20 -> authorized_key (rsa 기반) 자동으로 등록하는 명령어 ssh-copy-id |

패스워드, 키기반 인증 두 가지로 되어있고, 키가 없으면 패스워드 인증을 해야한다.

클라우드에서는 템플릿, 이미지라고 하는데 컴퓨터를 하나 만들 때 기본적으로 운영체제가 설치된 가상컴퓨터를 띄운다.
거기에 루트나 사용자의 패스워드를 넣어놓는다면 클라우드는 만들어서 쓰는거다.

안 쓰는 것을 지우는 이유가 auto connet

caeium 133(원자) 약 92억번 진동을 하는데 그게 1초

NTP 컴퓨터의 로컬 시계, NTP 서버, NTP 클라이언트

NTP의 도움을 받아서 컴퓨터 시간이 잘 맞는다. GPS 도움을 받아서 맞추는 시계도 있다.

www.pool.ntp.org 서버 pool을 모아놓은주소

UTC : 영국기준으로 세계 협정시간
GMT : 그리니치에서 만든 국제표준시

TIMEZON

방화벽
(service)       (software)
iptables
ip6tables       firewalld       
ebtalbes        ufw
(ethernet, bridge table)        
netfilter

운영체제 방화벽은 호스트방화벽 이라고한다.
커널에 netfilter라는 모듈이 존재한다.       /       커널에서 네트워크 
가장 저수준의 도구 iptables command -> 정책을 만들 수 있다. / 어렵고 복잡하다.
추가적인 관리도구를 이용한다.
기본적으로 사용하는 테이블 이였다.     (어렵다)
레드햇은 firewalld를 이용해서 관리하고 우분투는 ufw를 이용해서 관리한다
리눅스마다 관리도구가 다 다르다.

ml (markup language) 확장자
xml
html
태그를 이용해 문서나 데이터를 명기하는 언어

iptables -L
내 필터의 정책
