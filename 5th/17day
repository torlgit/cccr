스케줄링 :
시스템을 관리하게 되면 특정 시간 또는 특정 주기마다 작업을 실행해야 할 때 예약을해서 작업을 한다.

office 1주일에 한번 update
windows도 주에 한번 update message가 온다.

서버 같은 경우 update뿐 아니라 작업파일을 업데이트를 한다던지,
tar를 이용해서 테이프에 아카이브를 한다던지..

백업은 정말 많은 리소스를 소모를 해야 하기 때문에 업무 시간엔 하기 힘들고,
새벽, 주말 새벽에 작업을 많이한다.

직접적으로 명령어를 쳐야되면, 작업자가 
스케줄러를 등록하면 특정 시간에 특정 어플리케이션을 작동 시킬 수 있다.

단일성 작업 :
한번 실행하고 다시 실행하지 않는 것
또 다시 실행하려면 다시 스케줄러를 등록해야한다.	/	일반적으로 많이 쓰이지 않는다.
사용법도 많이 어렵진않다.

커맨드 - at
crond 시스템이 부팅을 할때 crond를 작동 시킨다.	/	 주기적 작업이 되지만 1회성도 가능하다.
특정 시간, 특정 날짜에 예약을 해서 실행 할 수 있다.
주기성 작업도 가능하지만, 단일성 작업도 가능해서 at 를 잘 안쓴다.

주기적 작업

crontab 명령어
/etc 디렉토리 밑에 tab 란 파일이 몇 가지 있는데, 테이블을 나타내는 파일이다.
액셀의 테이블 시트, 등을 예로 들 수 있다. 액셀과 같은 테이블은 아니지만 테이블을 텍스트로 구현해놨다.
(정보목록을 가지고 있다)

which crontab

crontab -l
no crontab for user - crontab이 없다.

crontab -e (edit)
테이블 형식으로 (분 시 일 월 요일 명령어 순서로) 텍스트 저장을한다.
여러가지 형식의 작업을 하고 싶으면 한 줄에 한 테이블씩 작성을 하면된다.
분은 숫자로 입력 0~59까지 지정이 가능하다
시는 24시간 형태 0~23까지
일은 1에서 31까지
월은 1에서 12월, 달 반드시 세 자리 이상만 쓰면된다.
요일은 0에서 7까지 - 0과 7일 일요일 / 세 자리 이상 문자로도 사용해도된다.
명령어 command .

메타문자 (특수문자가 의미를 갖고 있다.)
grep, sheel 처럼.

* : 매 요일, 매 분, 매일을 의미한다.
- : 숫자인 경우 범위를 나타낼 수 있다.	/	요일에 1-6 (월~토)를 나타냄
, : 여러가지 항목을 지정 할 수 있다.	/	분인 경우 10,20,30,40,50 (10분마다 의미)
각 필드당 공백으로 구별한다.
/ : 조건에 대한 주기를 지정	/	 */10 = 10,20,30,40,50 10분마다를 의미한다.

0 0 30 1 1 로 지정 했을 때, 1월 30일이 월요일이라는 조건이 충족해야 실행이 된다.
-e 파일 수정, 자신 계정 ID가 들어간다.

crontab은 특정시간에 특정 명령어를 실행하기 위해서 사용한다.
파일을 사용하여 crontab등록 = 아규먼트, 파일 등록하면 자동으로 실행	/	잘 쓰이진 않는다.

crontab -r 몽땅 다 지워진다	/	특정 작업만 지우고 싶으면 -e로 해당되는 내용만 지워야한다.

system cron (관리자가 사용하는 것	| 다른 사용자 권한)
그전 형식은 user가 사용
일반 cron은 내 소유권이다.

cron의 문제 :
특정 시각을 지정해놨는데 시스템이 꺼져있다면? --> 실행을 안한다.

이걸 위해서 anacron이라고 개선이 되어서 나왔다 | 주기능이 아닌 보조기능이다.

etc cron.d = 추가적으로 정보 crontab

cron.d *	(daily, hourly, monthly, weekly) 등

어플리케이션 설치 시 자동 등록이 될 수 있다.
anacron은 형식이 틀리다. 실행 할 수 있는 모든 것 shell script (실행권한 있어야한다 / 쉘 스크립트 형태)
터미널을 이용하지않는다.

쉘을 이용한다랑 터미널을 이용한다는건 다르다.
기본적으로 프로세스들은 터미널이 없어도 쉘만 갖고도 실행이 가능하다.
터미널은 우리한테 필요하지만, 시스템에는 필요없다.

period in days - 작성 발생 일 수 (1일에 한번, 7일에 한번, 달에 한번)
delay in minute - 특정 발생 시간
job-identifier - 로그에 표시된 ID (식별자)
command - etc/cron.d 실행

cron - 일반 : /var/spool/cron
       시스템 : etc/crontab
		   .cron.d
		   .cron.hourly

anacron	/etc/anacrontab
	    /cron.daily
	    /cron.month
	    /cron.weekly

디스크 관리
motherboard = 메인보드, logic board 등
IO를 어떻게 처리할 지 결정한다 (input, output)	/	데이터송수신, read&white
데이터의 입출력, 데이터의 구조를 알고 있어야한다.
나중에 클라우드 (가상)으로 하지만, 피지컬(물리적) 으로 하는것과 구조가 바뀌지 않는다.

northbridge (포트, interface)

southbridge

옛날 컴퓨터는 이렇게 두 가지로 나뉘었는데,
southbridge가 하는 역할을 cpu가 해서
요즘 브리지 또는 메인보드의 칩셋이라고 한다.
모든 입출력 장치를 통제하는게 브릿지이다.

그래픽카드는 부동소수점 연산을 잘하게 만들어졌다.
cpu같은 경우는 정수 연산에 최적화 되어있다.

3d게임 같은경우는 부동소수점 연산을 많이 해야한다.
똑같은 기능을 하는 소프트웨어보다 하드웨어가 빠르지만, 모든 기능을 하드웨어로 만들 수 없다.

form factors : 메인보드의 생긴 모양, 크기, 구조	/	서버는 standard, 가정용 micro atx

dram : 보통 우리가 사용하는램	/	ddr4가 현재표준

ISA (거의 볼 수 없다 20~30년됨) -> PCI/AGP (그래픽카드 전용, 지금은 x) -> PCIe
10진 단위를 SI라고 한다. (접두어 prefix)

디스크를 PCIe로 연결하는 디스크를 만든다.

디스크를 연결하는 IO 방식
IDE(parallel ATA) 병렬 ATA, 표준 E-IDE (IDE 마지막으로 쓰던 ....)	/	SATA : 직렬 ATA
통신하는 방식은 직렬, 병렬이 있다. UTP 직렬
네트워크 통신이든 IO든 직렬로 통신한다.

병렬은 8개의 선이 있으면 1초 8bit를 한번에 전송	/	직렬 방식은 8bit를 보내는데 8초가 걸리다.
 : 한꺼번에 많은 정보를 전송하기 때문에, 이론상으로는 빠른게 맞을 수 있다. 병렬은 멀리 전송하는게 어렵다.
   우리가 전송하는 속도가 옛날에 비해 어마어마하게 많이난다.
   길이가 조금만 틀어져도 제대로된 송수신이 안되서 병렬을 쓸 수 없다. 그래서 대부분 통신은 직렬통신이다.

DMA : 167MB/s 최대의 속도
esata : 디스크를 컴퓨터 외부에 꼽는 방식 / usb보다 빨랐지만 요즘엔 안쓴다.

IEEE 1394 : USB가 너무 느려서 사용 했었다.	/	USB를 통합해서 현재는 사용하지 않는다.
USB가 포트도 간결하고 쓰기도 쉽다. 3부터 3.1, 3.2로 구별한다.
thunderbolt 3 
Infiniband : 서버에 존재한다. / 특이한건 시스템 IO처럼도 작동하고, 네트워크 기능도 있다.

서버같은경우는 SCSI (스커지) : 병렬통신, 옛날 통신방식 -> sas : 직렬 연결된 스커지 서버에서 사용
SATA - SAS 는 IO가 호환이된다.

SCSI, SAS, SATA => HOT Plugin	=	USB, flash Memory
(온라인 = 현재 실행되고 있는 것 = hot) / (오프라인 = 시스템이 꺼져 있는거 = cold)
PnP (plug and play) = 연결하면 작동한다.

확장 플러그인(확장포트) = hot plugin 적용이 안되서 재부팅을 해야한다.
아주 고가의 서버는 hot plugin 적용되지만, 아주 드물다.
현재 사용하는 장치를 빼면 안된다. =  cold / usb는 필요에의해 탈착 가능 = hot

SCSI command 내부적으로 파일을 저장하거나 읽을 때 (프로토콜이라고 생각해도된다) scsi 명령어를 쓴다.
sata랑 sas의 포트의 모양이 똑같다 sata의 disk를 sas에 연결 할 수 있다.
sas의 디스크는 물리적으로 똑같기 때문에 연결이 안된다. (동작이 안된다 / sas의 기능이 많기 때문에)

HDD = 하드 디스크 드라이브 
3.5형 = 3.5인치 / 디스크 컨트롤러 (DISK IO) : SATA3 / 7200RPM 분당 속도 / 메모리 BUFFER MEMORY
노트북은 2.5인치를 사용한다. 5200RPM으로 느리다.
10K, 15K 서버에서 사용 / 15000RPM

SSD = 기본적으로 SATA / 2.5인치 , SAS용은 없다.
IOPS = input, output 처리량
SSD는 용량이 크면 클수록 용량이 더 빠르다.

M2 SATA = 노트북용으로 만든 SSD / 모양은 M2인데 SATA를 쓰는 방식
NVME = 서버용으로 사용하는 SSD = SATA 방식이 아닌 PCI 방식을 사용한다.

All flash storage	//	PCI, M.2

디스크의 물리적인 구조
플래터(platter) : 실제 데이터가 저장되는 위치, 디스크에는 한 개 이상의 플래터가 존재하고, 양면기록이 가능하다.

스핀들(spindle) : 플래터를 회전시키는 역할을 담당한다. 
 rpm(round per minut) 스핀들 모터의 회전속도를 의미한다.

헤드(head) : 플래터에 데이터를 기록하는 기능

액추에이터(Actuator) : 디스크 플래터를 원하는 위치에 있는 데이터를 읽어오기 위한 암을 이동시키는 역할

액추에이터암(actuator arm) : 액추에이터에 의하여 움직이고, 암마다 헤드가 붙어있다. / 좌우로 움직인다.

커넥터(connector) : 디스크의 연결 인터페이스 종류에 맞는 케이블을 연결 / IDE, SATA, SCSI, SA-SCSCI 등을 사용

점퍼 블록(jumper block) : IDE인터페이스를 상ㅇ하는 하드 디스크의 경우 master/slave결정하기 위한 점퍼
 현재 디스크에는 없다.

전원 커넥터(power connector) : 디스크 구동에 필요한 전원케이블을 연결한다.

하드디스크는 기계적, 물리적으로 읽어야한다.실제로 데이터를 읽거나 쓸 때 더 오래걸린다.

seektime

rotutional latency

trasmission

(정리)

디스크 플래터의 논리적인 구성요소
섹터(sector) : 플래터의 가장 작은 단위, 1개 섹터 크기는 512byte 이다.
 가장 기본단위이며, 가장 작은 입출력단위이다.
 1bit이든 10bit이든 하나의 섹터를 전송해야한다.

트랙(track) : 섹터가 모여 하나의 원을 구성하는데, 트랙은 많은 수의 섹터를 가지고 있으며, 플래터 내에 여러 개의 트랙이 존재한다.	/	섹터가 한 바퀴 돌면 트랙이라고 한다.

실린더(cylinder): 여러 트랙을 모아놓은 것

디스크(disk) > 파티션(partition > 실린더(cylinder) > 트랙(track) > 섹터(sector)

커널은 파일시스템을 논리적으로 만들어서 관리, 운영체제가 IO하는 최소 단위
UNIX = block , WINDOWS = cliust 파일의 최소 입출력단위
물리적인 섹터의 배수가 되어야한다.

파일 사이즈
한번에 처리할 사이즈
block / cliust 4kb = 1 block 8개의 섹터 / 이해가 안됐음 집가서 따로 찾아보자

디스크 파티션 :
논리적으로 구역을 나눈다.	/	정보를 저장하는 방식
MBR방식과, GPT 방식으로 나뉜다. -> inode table = 메타데아터 = 파티션도 포함되어있다.

MBR 저장방식
ms가 dos부터 사용한 방식 -> 현재는 리눅스에서도 사용이 가능하다.

MBR(master boot record) 파티션
BOOT CODE 0 ~ 440		/	bootloader, bootstrap
Signature 440 ~ 446
partition 446 ~ 460
partition table 460 ~ 476
partition table 476 ~ 492
partition table 492 ~ 508
Signature 508 ~ 512

MBR은 파티션을 최대 4개까지 밖에 나누지 못한다.
4개 이상의 파티션이 필요할 경우 확장 파티션 기능을 사용하여 4개 이상의 파티션을 사용할 수 있다.

섹터의 주소를 4 Byte로 저장하기 때문에 최대 크기 제한이 발생하고,
한 개의 섹터는 일반적으로 512 byte이고, 최대 섹터는 2의 32승 약 43억개 정도이다.
용량을 환산할 경우 2tb가 나오는데, 4tb이면 2tb까지만 인식이 되고 나머지는 인식이 되지 않는다.

궁금증 : 4TB를 MBR로 하면 2TB만 인식이 된다는데 GPT를 사용하면 모든 데이터를 쓸 수 있는지,
2TB란 데이터가 하나의 primary를 말하는건지?

GPT(guid partiton table) 파티션
파티션 테이블 개수가 128개로 늘어났고, 각 파티션 테이블 당 128byte 씩 사용할 수 있다.
섹션 주소를 64bit로 저장하여 최대 8ZB 디스크를 사용할 수 있다.

MBR 방식 디스크 구조
MBR | Partition 1 | Partition 2 | Partition 3 | Partition 4 |
 
GPT 방식 디스크 구조
Protective MBR | Primary GPT | Partition 1 ..... partition n | secondary GPT

하나의 디스크 크기 / IT 발전속도에 의해 부족할 수 있다.

BIOS(basic input / output system) :
컴퓨터를 키면 제일 먼저 실행 (mbr 형식만 가능)

EFI/UEFI(extensible firmware interface nifed EFI) :
바이오스, MBR, GPT다 가능하다

BIOS, EFI/UEFI는 POST 과정 중 실행한다.

MBR
GPT
ARM (애플 방식) / 기본으로 위 내용을 지원한다.
BSD (리눅스 방식) / MBR, GPT 기본으로 지원

리눅스 시스템 스토리지 장치명
인터페이스별 장치면 + 장치 번호 + [파티션번호(숫자)]
 장치번호는 숫자, 문자를 의미한다.
 windows는 파티션마다 할당 / unix는 하나의 장치 = 하나의 번호이다.
 1부터 시작한다.

E-IDE 인터페이스
'hd' 장치명을 사용한다.	/	
 장치명은 hd부터 순차적으로 알파벳이 붙고, 파티션 번호는 1부터 순차적으로 부여된다.
 ex) hda	/dev/hda   |	hda1	/dev/hda1 등

현재 최신 리눅스 시스템은 과거의 hd 명명 방식을 사용하지 않고 sd 명명 방식으로 통일되었다 -> EIDE는 안쓴다.

SATA/SCSI/SA-SCSI
'sd' 장치명을 사용한다.	/	어떤 방식을 사용하든 전부 통일시켰다.
 ex) sda	/dev/sda

CD-ROM (ODD)
UNI AKEK sd, sr로 나뉘는데 서버에서 사용하지않는다.
 ex) sr0	/dev/sr0

핫 플러깅 :
스커지만 해당 되는데 / 장치를 인식 시키고 장치 파일을 생성하는 방식 | 현재는 사용하지 않는다.
스캔을 하면 새로 장치가 보이면서 스캔이 실행된다.
echo '- - -' 명령어를 사용해서 스캔한다.

잘 사용하지 않지만 스커지를 할 경우 p 97~98 참고

fdisk MBR 방식
gdisk GPT 방식
pated 안쓴다	/	gparted 안쓴다

디스크 인식 -> 파티션 -> p.s 생성 -> mount	/	/dev/[파티션] * 수정
윈도우는 mount전 까지는 unix와 동일하다.	/	파티션이 여러 개면 여러 개의 ps, mount가 존재한다.

fdisk(mbr), gdisk(gpt) :
파티션을 나누는 명령어

p107 복사해서 붙여넣고 설명 쓰기

파티션 포맷을 바꾸려고 할 때 사용
dd if =/dev/zero of=/dev/sdc bs=512 count=500
zero로 파티션 c를 덮는다.

시큐어딜리트 :
보안삭제, 디스크 사이즈에 따라 시간이 바뀐다.

파티션 설정 시 주의사항
파티션1과 2의 데이터가 겹치면 안된다.
파티션1과 2사이에 사용되지 않는 데이터를 남기면서 만들게되면 파티션이 꼬인다.
파티션과 파티션을 겹치면 안된다. 	/ EXTENDED, 논리파티션은 예외로 취급한다.

확장 파티션
확장 파티션은 MBR 방식 파티션에서 4개 이상의 파티션을 사용 할 수 있는 방법을 말한다.
