어제 배운 내용

병렬		|	직렬

IDE(PAT)	->	SATA
SCSI		->	SAS

SCSI(스커지 커맨드를 사용)

먼 곳을 통신할 때 병렬은 좋지 않아서 IT는 직렬 통신한다..

/DEV/hd	(IDE 방식)	- 안 쓴다.
    /sd
    /sr

disk 인식 -> 파티션 (MBR | 2TB / 32 / 파티션 4개 주, 확장 - 논리, GPT 64, 128개 주, 확장없음-> F.S 생성 (EXT (50TB), XFS(500TB) -> mount (/etc/fstab, /etc,/mtab (커널관리)

스왑 메모리

virtual memory = 가상메모리	=	physical memory (RAM) + swap space
자기가 사용 할 수 있는 총 메모리는 virtual memory로 인식을 한다.
swap은 있을 수도 있고 없을 수도 있다. 없다면 physical memory와 크기가 동일

메모리는 디스크에 비해 용량대비 고가이다. 메모리가 커야 동시에 많은 프로그램을 돌릴 수 있다.
메인보드 칩셋에 따라 메모리량도 정해져있다.

결론적으로 메모리는 계속해서 늘릴 수 없을 뿐더라 용량대비 너무 고가이다.
디스크의 일부분을 메모리 처럼 쓰는 걸 swap space라고 한다.
스왑 영역은 파일시스템 체크가 필요하지않다.

아무것도 안하고 있는 것만 swap으로 간다.	/	동작을 하게 되면 다시 메모리로 사용한다.
swap을 하는 이유는 메모리를 늘리게 하려고.

swap out : 안 쓰고 있는 프로그램으로 swap이 되는 현상
swap in : 안 쓰고 있던 프로그램을 다시 사용할 때 memory로 돌아가는 현상

메모리 기준으로 in, out 해야한다.

Hibernation :
	절전
	최대절전 - Hibernation

절전, 최대절전 : 기본적으로 컴퓨터를 일시정지 되는 현상
절전은 시스템이 꺼져 있는 거 처럼 보이지만 켜져있는 상태로 전원은 돌아가고 있다.
최대절전 : 메모리에서도 전원을 차단해서 절전을 더 많이 할 수 있게 한다. / memory에 있는 걸 swap에 들어간다.

최대절전을 사용하려면 swap 공간이 physical memory 용량보다 커야 사용이 가능하다.
서버는 해당 사항이 없다.	/	일반적으로 서버에서 목적은 많은 메모리를 제공하는것
메모리가 충분하게 있다면 swap은 굳이 필요하지 않는다.

swap은 성능을 높이고 많은 메모리를 사용하기 하는데 swap memory가 HDD - 5400 RPM 같은 느린 장비를 사용하면 전송 속도가 느리고 속도 저하가 올 수 있다.	/	병목현상이 발생한다.
Page : swap의 단위

getconf PAGESIZE : 
swap은 page 단위로 in, out을 한다. = paging (페이징)

모든 OS는 메모리와 swap을 paging 단위로 out, in 한다.
ms에서는 swap 이란 단어를 사용하지 않는다.

swap file = swap disk	/	swap partition (많이 사용한다 / 선호)
swap file은 file 제공으로 partition보다 느리다.
partition이 없으면 file 을 만드는 방법 밖에 없다.
ms는 파일로만 관리한다. c드라이브 밑에 pagefile.sys (숨김파일) = pagefile // virtual memory

p.s을 생성을 하고 허용을 해줘야한다. (파티션 - 마운트 과정과 비슷하다)

기본적으로 처음에 운영체제를 설치 할 때 memory에 따라 swap을 정한다.

free command
mem (physical)
swap memory

메모리가 꽉 차야지 swap을 하는 건 아니다. / 사용할 수 있다.

mkswap /dev

swapon [옵션] [파티션 | 파일이름]
 -p : 우선순위 해당되는 스왑장치를 더 많이 쓴다. (연결한 장치 순서대로) / ssd 같은 고속 저장장치를 쓰면 그 장비를 우선순위를 주면된다.

swapoff - 조건은 해당되는 장치가 사용하고 있으면 안된다.
fstab에 기록해야한다.

메모리 / 네트워크 기반
내가 파일시스템 체크를 하는게 아니라, 

mkswap /swapfile [파일 지정]
swapon /swapfile

swap을 사용하려면 파티션이 빠르다. 파티션이 없는 상태에서만 파일을 고려해볼 수 있다.
더 많은 프로세스, 최대 절전을 고려 했을 때 swap이 존재해야한다.

일반적인 형태에서 swap을 하는 사이즈

vi /etc/fstab을 추가한것만 지우기
swapoff -a , umount -a	/	sda 건들면 시스템 날아간다.

논리적인 볼륨을 관리한다고 해서 볼륨관리자
disk가 단일 파티션 3개로 묶어서 하나의 volume을 만들 수 있고 f.s 을 생성해서 사용할 수 있다.

앞에서 했던 파티션 사이즈 조정이 안된다. 삭제했다가 다시 만들어야하는데, (데이터가 다 날라간다)

쉽게 얘기해서 root

volume이란걸 만들게 되면 파티션의 사이즈 조정이 가능하다.	/	raid를 지원한다.
기업에서는 volume, raid가 중요하다.

장치를 파티션을
hol disk (파티션을 안나눴다)	디스크 전체를 쓴다.
필요에 의해 파티션을 나눈다.

Disk -> partition (필요에 따라서) -> LVM -> F.S -> Mount

disk를 물리 볼륨 (PV) 디스크, 파티션 하나 하나를 물리 볼륨으로 구성해야한다.
5개의 디스크를 5개의 PV로 만든다.
PV를 합쳐 볼륨 그룹 (VG)를 반든다.
VG를 필요에 따라서 논리 볼륨 (LV)으로 나눈다.

LV에 P.S를 만들고 Mount를 해주면된다.

Device Mopper(dm) 장치를 연결 시켜준다.	/	/dev/dm
자동으로 만들어준다. 늘릴 수 있지만 줄이는 건 불가능하고 줄일 이유도 없다.

/dev/[vg]/[lv]

ms windows는 volume 매니저가 있다. 조절이 가능하다.
베리타스 볼륨매니저라는 소프트웨어가 참조되어있다.	/	옛날부터 있었다.
VM(볼륨매니저) 기본 작동

물리 볼륨
볼륨 그룹
기본적으로 4MB크기로 생성이 된다.
논리 볼륨

명령어 [command] [속성]

PE = 4MB (기본 값) = 하나의 PE : 4MB

내용 보충

dm2 	- /dev/dm-2
	- /dev/mapper/[volume]

Lvm을 사용 안하면 일반파티션이 되는데 확장이 안된다. LVM을 쓰면 확장이 된다.
지울 때 역순으로 지운다.

삭제 할 때 장치명이 하나라도 남아있으면 안지워진다. pe는 무조건 하나의 lv만 가능 (보충)
물리 볼륨으로 변환 할 때 파티션을 나누지 않을 경우는 굳이 파티션을 해서 나눌 필요가 없다. / 바로 명령어 입력하면된다.

위 3가지 명령어 / 보는 명령어 / 속성 추가 입력

선형 논리 볼륨 :
일반적인 방법으로 생성되어 있는 논리 볼륨의 형태를 선형 논리 볼륨이라고 한다.
전체 물리 볼륨의 PE를 나열하고, 생성할 논리볼륨에 순서대로 PE를 할당하는 방식이다.

lvm을 이용해서 RAID를 만들 수 있다.
RAID (중복대열)	/	합친다.

옛날에는 큰 디스크가 필요했는데, 디스크가 비싸서 싼 디스크를 합쳤다.
개별독립적인 디스크를 여러 개를 묶어서 하나의 볼륨으로 묶는 방식

디스크를 묶는 방식에 대해서 레벨이 존재한다.

스트라이프 볼륨(striped volume) :
스토리지의 사이즈와 성능을 중시하는 논리 볼륨 생성 방식
lvm과 같이해서 데이터를 갖고 해야한다. 양쪽의 사이즈가 항상 같아야 한다.

raid 방식
하드웨어 자체에서 raid를 구축한다. (하드웨어가 속도가 훨씬 빠르다 가격이 비싸다)
메인보드 칩셋에 따라서 지원되는 raid level이 다르고 지원을 안하는 경우도 있다.
raid control라는 제품을 달아서 확장을 할 수 있다.
서버용 메인보드는 보통 다 지원한다.

소프트웨어 raid (lvm은 소프트웨어에서 구성하는 방식이다)	/	유닉스,리눅스 지원하기에 가능하다.

raid 0 :
실제로 현재는 stripe라는 별명을 갖고있다. (옛날에는 concatenated = span vol =  jbod 라고 했다)

non-radi
디스크를 단순하게 묶어 놓은 것 (jbod = 논리볼륨 만든거와 유사하다)
선형적으로 쓰는 방식, 단순하게 큰 볼륨을 만드는 목적 밖에 없다.

raid 0 (stripe) : 
데이터를 쓸 때 가로로 묶는다. 블록이 8개가 필요하면 
쓰거나 읽는게 빠르다. 동시에 쓰고 읽을 수 있다. 속도를 높이기 위한 목적으로 사용
오로지 용량과 퍼포먼스 측면에서 가장 좋다.	/	장애처리가 안된다.

치명적인 문제가 있다.
디스크가 깨지면 (폴트) 파일 시스템이 깨지거나 문제가 생긴다면 아무 데이터에도 접근을 못하게된다.

raid 1 (mirror) :
2 way mirror 2개의 디스크를 동시에 저장하는 방식
하나의 디스크만 멀쩡하면 데이터가 온전하게 보존 할 수 있다.

최악이 뭐냐? - 2개를 해도 하나의 용량밖에 못 쓴다. / 하지만 장애처리는 제일 좋다.
쓰기 속도는 하나만 쓸 때보다 안 좋아질 가능성이 존재한다. 똑같거나, 읽기속도는 빨라진다.

raid
2 spripe bit
3 spripe byte
4 spripe block
안 쓴다. 디스크는 2개 이상 있어야한다.
데이터를 stripe로 쓴다. parity를 쓴다. 디스크가 3개 필요하다.
xor 연산 방식이라서 장비 하나가 고장나도 
디스크를 3개 사용하게 되면 효율이 3/2 만 사용이 가능하다.
dadcated parity disk

5 기본적으로 데이터를 2개만큼 parity를 1개만큼 사용한다. parity를 분산해서 저장한다. 디스크 하나를 parity로 소모된다. 하나만 고장나는건 허용, 두 개 고장나면 복구 할 수 없다.
2,3,4 방식과 무슨 차이가 있나?/ 장애가 났을 때 훨씬 이점이 있다. 확률적으로 3분의 1에 대한 데이터를 계산을 하지 않아도된다. 분산해서 저장하는게 효율이 더 좋기 때문에 위에 방식을 사용할 이유가 없다.
6 데이터 3개 parity를 2개 저장한다. 디스크가 최소 5개 있어야한다. 디스크가 2개 고장나는거 까지 허용이된다. / 잘 안쓴다.
distrbrted parity disk (분산한다)
데이터디스크와, parity 디스크 2개만 사용한다.

결론 standard에선 0,1,5만 사용한다.
0은 성능위주 (디스크 하나만 장애나도 모두 장애가 난것과 같다
1번은 데이터 손실 성능을 어느정도 높이면서 고장을 허용을 하는 단계

FT를 지원. (장애 극복) 무정지라고도 한다.
장비가 하나 고장이나도 정상작동, 두개가 고장이나도 정상작동 등.

Nested (하이브리드)
1+0 = 10 / 복합적으로 사용한다.

rad 0+1
디스크 4개가 필요하고,
디스크 2개씩 spripe 미러를한다.

평소에는 2개가 아무 차이가 없다. 공간 효율성은 50%
읽기성능은 stripe 한 만큼 좋아진다. 1개 일수도 있고, 최대 2개까지 장애가 나도 복구 할 수 있다.
볼륨 하나가 죽으면 같이 죽은것과 같다(영향을받는다). 핫 플러그인이라 새거를 꽂으면된다.
새디스크를 꽂으면 데이터를 채워넣는다. 고장이나서 교체를 하면 4개가 동시에 io가 이루어지고 있다.
raid 1+0
공간 효율성, 성능 같다.
근데 장애가 났을 때 장비를 교체 하면 0+1 방식에 일을 덜한다.
하이브리드 중에는 굳이 쓰려면 1+0을 사용한다.

stripe + parity (오류 검출)
parity wiki - 짝수, 홀수 페리티 crc ckeck sum이 페리티의 개념이다.
XOR(베타적논리합) 연산을 사용한다. / 같으면 0 다르면 1 어떤 값이 지워지더라도 계산으로 복구해낼수있다.

100%FREE (100% 사용한다는 의미)

Non-standard levels (비표준 레벨)

내용을 정리하고, 명령어에 관해서 책보고 다시 정리

씬 프로비저닝

Thick
	proision
Thin

스토리지관련 기술 실제로는 사용하고 있는 만큼만 할당, 가상화 기술이다.
미래를 예측을 해서 부족한 만큼 스토리지를 구매를 해서 보유를 해야한다.
가상화에서 중요한 개념이다
물리 볼룸 -> 볼륨 그룹 -> 씬 풀 -> 논리 볼륨 단계로 씬 풀 생성 단계가 추가 된다.
-V 는 vitual size를 의미한다.


VG 50G	/	LV 10 : 100G
Overcommitment, Overcomit 넘는걸 허용한다.
실제 가지고 있는거보다 오버해서 표현하는걸 허용한다.
os가 있는 디스크가 pool되면 시스템이 종료가된다. => 필요없는 파일을 지워야한다. (용량 확보)

볼륨 그룹 확장
vgextend [볼륨이름] [장치] (명령어 방식)

볼륨 그룹 축소
vgreduce [볼륨그룹이름] [장치]

볼륨 축소는 확장과는 달리 사용 중이면 여분의 물리 볼륨에 데이터를 옮겨야한다. (pvmove)

pvmove [장치] / 자기 장치의 볼륨을 쓰면 된다.
하나의 pv라도 남으면 해제가 불가능하다.

보통 기업에서는 사내 방침에 따라 고장이 나기전에 교체를 한다.
교체를 하려면 pvmove로 데이터를 옮겨야한다.

blkid [파일시스템] 을 보는 명령어

논리 볼륨 확장
lvxtend [옵션] [논리적볼륨경로]
	-r 옵션을 사용하면 파일시스템을 몰라도 자동으로 적용시켜준다.

논리적 볼륨을 확장 할 때 lv를 먼저 늘리고 파일 시스템을 늘려야함.
실제 존재하지 않는 공간 데이터를 쓰려면 오류가 뜬다.
파일시스템에 따라 command가 다르다.

+기호추가
숫자만 쓰면 그 숫자로 만든다. (-개념)

df -T : 파일시스템 나온다.

xfs_growfs [mount-point] -> xps
resize2fs logical-volume-path -> ext4
 
논리 볼륨 축소 (하지마라	/	볼륨이 깨지는 경우가 생긴다)
lvreduce [옵션] [logical-volume-path]
	-r 옵션을 사용하면 파일시스템을 몰라도 자동으로 적용시켜준다.
사용하는 용량 중 사용하지 않는 것

resize2fs logical-volume-path size
		[장치]	[줄일 사이즈]

권장 x

늘릴 때 사이즈 지정 X	/	줄일 때는 줄일 사이즈를 지정해야한다.

결론 : EXT4 파일 시스템만 축소가 가능한데, 볼륨 자체가 깨질 수 있어서 권장하지않는다.	/	실제로도 안쓴다.
XFS는 줄여는 기능 자체가 없다.
