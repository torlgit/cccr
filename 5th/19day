서비스 :
네트워크에 서비스와 다르다.
시스템이 부팅을 할 때 백그라운드에서 실행할 프로세스를 실행해주는 기능을 서비스라고 한다.

컴퓨터가 꺼질 때 까지 계속해서 프로세스 동작을한다.
모든 운영체제는 서비스가 존재한다. 스마트폰도 서비스가 존재한다.

대표적으로 제일 많이 사용하는 우분투, cent os
우분투는 1년에 두번 4월, 10월에 나오는데 버전들을 보면 lts 가 붙은게 있다. 길게 지원을 한다. (서버로 사용하는 os는 lts만 사용한다)

lts는 기본적으로 10년을 지원한다.

red hot은 모든 버전이 11년을 지원한다.

아직까지도 현업에서는 cent os 6버전, 우분투는 12.04 버전도 많이 쓴다.
이전 버전의 구조도 알아야한다. cent os는 6버전, 우분투는 16.04 systemd를 사용했다.

init -> upstart -> systemd

intit -> sysV : 유닉스의 표준 / 서비스를 제어하는 녀석 개선보다 새로 만드는게 좋다라고 생각해서 바꼈다.

unix는 init을 한참 전부터 사용하지 않았다. 개선하기 위해서 upstart를 만들었지만, 기능만 조금 추가 된거라 init은 계속 사용되었다.

systemd - 레드햇 계열	/	upstart - 데비안 계열

하지만 지금은 systemd를 사용한다.

PID = 1이다.
상징적인건데 리눅스 커널의 스케줄러가 프로세스 0번이다. 커널이 최초로 실행하는게 1번 프로세스이다.
예전에 init은 서비스만 관리 했는데, systemd는 서비스 뿐 아니라 시스템에 전반적인것 모두 관여한다.

systemd를 사용해서 서비스를 다룰줄 알아야한다. 관리를 하는것이지 제어할 일은 거의 없다.

/etc/inittab
runlevel : 동작레벨에 대한 설명 0~6까지
운영체제가 동작을 하는 레벨	/	 윈도우에는 없는 기능, 윈도우 안전모드 (굳이 비슷한걸 꼽으면 안전모드가 비슷하다)

정상적인 레벨은 2개밖에 없는데, 3번과 5번이다.

3번은 full mltiuser mode	5번은 x11 (GUI를 컨트롤)
3번과 5번은 똑같다. 3번은 gui가 없는 5번은 gui가 있는 차이를 가지고 있다.

그래서 id:3:initdefault : 으로 cent os가 출력이 된다.	/	

/etc/rc3.d/
서비스를 실행할 쉘 스크립트
ls -l 해보면 심볼릭링크로 되어있다. (inin.d로 되어있다)

rc1.d	rc2.d	rc3.d 등등이 다 init의 심볼릭링크로 되어있다.

S|K NN <서비스명>
S : Start	K : Kill  (stop)
demon process를 띄워준다.
k는 이미 동작되어있다면 멈춰준다.
숫자는 순서대로 작동한다.

쉽게 보려면 chkconfig 명령어 사용
왼쪽엔 서비스이름 level에서 start 하면 on stop이면 off로 되어있다.
on, off는 조절 할 수 있다.

리눅스는 레벨에 따라서 똑같은 서비스가 가동, 중단 할 수 있다.
실제로 rc.3 번에 있는 스크립트를 실행한다. -> 서비스를 스타트한다.

service --status-all | more
service crond (status, stop, start)

커널이 최초로 실행하는게 init 프로세스이고 init이 모든 프로세스를 컨트롤한다.
단계적으로 레벨을 올라가려고 하고 레벨마다 다른 서비스를 스타트, 중단을한다.
스타트 하다가 여러가지 이유로 중단을 할 수도 있다.

옛날 init 방식이다.

/etc/init	=> upstart (init 기능을 추가한것)

init과 systemd의 차이
서비스를 직렬로 실행시킨다. 여러 개의 각각 서비스를 동시에 실행시키지않는다. (순서가 존재한다. 차례차례로)
번호를 보고 알 수 있다. 순서, 직렬로 실행한다.

systemd는 서비스를 병렬이라 한번에 여러 개를 실행 할 수 있고, 속도가 빠르다.

부팅이 정상적으로 완료하려면 필요한 서비스가 가동이 되어야한다. 병렬로 처리하면 여러 개를 빠르게 킬 수 있고 부팅 속도가 빨라진다.

서비스간의 의존성 디펜더시
s13iscsi - 인터넷 스커지 / 네트워크 기반의 스토리지
네트워크가 연결되어있어야하는 스토리지	/	네트워크 기능을 의존하고있다.
s10network - 네트워크를 가동을 하는 스토리지
network가 작동하지 않으면 iscsi는 가동 할 수 없다.

init의 단점 중 하나가 의존성을 정의 할 수 없다.
오로지 번호로 네트워크로 먼저 실행을 할 뿐 iscsi는 network가 없으면 실행이 안된다는걸 모른다.

서비스 자체에 난 누구를 의존하고 있어요. 라고 선언 할 수 없다.
모든 서비스는 적절하게 순서를 지켜서만 실행 할 수 있다.

start 순서를 바꾸면 시스템이 난리가난다.	/	개발자가 개발할 때 결정함.

여러가지 이유가 있지만 위 2가지가 가장 큰 이유이다.

네트워크 설정을 변경을 하면 재시작을 해줘야하는데, 네트워크를 이용하는 다른 서비스들은 네트워크가 재시작하는걸 알수 없는데, 시스템에 문제가 심각하게 발생 할 수 있다. 시스템 관리에 상당히 어려움을 갖고있다.

init만 쓰든 upstart를 쓰든 ... init은 서비스 간 의존성을 정의 할 수 없다. 서비스를 직렬로 실행한다.

systemd는 의존성 관계에 없는 서비스는 병렬로 실행 할 수 있다.

/etc/init은 7버전 부터 사라졌고, /etc/init.d는 남아있는데 네트워크 셀만 남아있다.
레거시 서비스 하위 호환성 때문에 init 형식이 남아있다.

systemctl = systemd를 컨트롤 히는 명령어
서비스 중에선 legacy도 존재한다.
legacy : 옛날, 이전형태를 의미한다.

systemd 유닛 : systemd는 쉘 스크립트가 아닌 유닛으로 관리를 한다. / 유닛파일
서비스 유닛, 타겟 유닛, 오토 마운트 유닛, 마운트 유닛, 장치 유닛, 경로(path) 유닛, 범위(scope) 유닛, 슬라이스(slice) 유닛, 스냅샷 유닛 (특정 상태를 저장 / 돌아가려고), 소켓 유닛, 스왑 유닛, 타이머 유닛

시스템에 전반적인 모든 것을 systemd과 관리한다.
우리는 service와 target을 제일 중요하게 보면 된다.	/	targer은  runlevel과 관련이있다.

/etc/systemd/sysem, /run/systemd/system, /usr/lib/sys-temd/systemd 중 /etc/systemd/system을 가장 일반적으로 사용

명령어
systemctl -get-default

systemctl 모든 유닛들의 상태들을 볼 수 있다.

systemctl [subcommand] [옵션]
	- list units (subcommand)
	- list-unit-files (
	enabled : 유닛을 시스템 부팅 시 실행하세요	
	dsiabled 설치는 되어있지만 실행하지마세요. / 수동으로 실행 가능	
	static 커널만이 제어가 가능하다. 유닛을 말한다. 커널이 자동으로 실행한다.
	masked : 제어를 못하게 임시로 막아놓은것 (풀어줄 수 있다) enabled, dsiabled 못 한다.
	동시에 작동 못하게 하려고 막아놓음

	enaled, dsibled (중요하게 볼것)
	
ACTIVEE, SUB는 현재 상태를 보여준다.
일반적으로 서비스들은 Running 상태가 정상적인 상태이다.

running waiting (정상적인 상태에서 부수적인 상태를 표현), exited
flug	
	235-236 참고
	- t : 서비스 종류에 유닛만 보는 옵션

	is-active 현재상태
	is-enabled 부팅 시 상태

	









log (event journal)
window는 event
linux journal

모든 어플리케이션은 이런 여러가지 이벤트를 발생시킨다.
이벤트를 통합해서 관리 하게되면 syslog를 사용한다.

event -> syslog -> 
개발자가 syslog를 사용하지 않을 수 있지만, 

프로세스들은 이벤트 or message를 발생시키고 syslog한테 준다.
syslog는 어떤 메시지를 어디다 저장을 하고 전송을 할지 정한다.
일반적으로 파일, 사용자(터미널), 원격시스템(다른시스템)

기업은 log서버를 따로 둔다.
시스템에 대한 모든 로그를 원격시스템으로 log서버로 모은다.
/var/log/+ 에 남아있다.

log는 보안을 위반했는지 안했는지 (감사)	| 어떤 어플리케이션에 대한 오작동 장애조취에 사용한다 (trouble shut) 

요즘엔 웹에 로그를 이용해서 어떤 ip가 접근을 했는지 뭘 눌렀는지 빅데이터로 분석을한다.
어떤 서비스를 좋아하고 어떤 것을 이용하는지에 대한 로그를 어떻게 저장을 할건지?

로그를 남기지 않으면, 이런 것들에 대해서 아무것도 할 수도 알 수도 없다.

최신 버전 같은 경우 rsyslog를 사용한다.
네트워크 라우터, 스위치도 로그를 이용한다.
클라우드에서도 로그를 사용해서 분석을한다.

systemd가 로그도 관리를한다.

systemd-journald 모든 메시지는 이 프로세스로 간다.
크게 두가지로 나뉘어진다.
systemd와 관련된건 journal로 가는데 unit에 관련된걸 말한다. 	/run/log/journal 경로 2진수 데이터로되어있다.	cat, more 등으로 열면 안된다.
log를 볼 수 있는 명령어가 있는데, journalctl 이라고한다.
systemd와 관련되지 않는건 rsyslogd한테 넘긴다.
rsyslogd는 (로그파일, 원격컴퓨터, 사용자)가 될 수 있다.
옛날 유닉스, 리눅스 syslog를 사용	/	기능만 추가된거지 나머지는 같다.

log files /var/log	|	syslog가 저장하는 파일들 more, cat 등으로 볼 수 있다.

/var/log/messages : 시스템의 거의 모든게 들어있다.
/var/log/secure : 인증과 관련된 로그
/var/log/maillog : 메일과 관련된 로그
/var/log/cron : crontab log, 등록한 스케줄러를 확인할 때 보는 로그
/var/log/boot.log : 부팅과정에 발생된 로그를 기록

로그 로테이트 (logrotate) 로그 순환
순환 시키는 이유 : 안시켜도된다. 안시키게되면 계속해서 누적이되서 나중에 어마어마하게 큰 사이즈가 되는 경우가 생긴다.	/	파일 하나가 계속 커진다.	중요한건 나중에 파일을 확인할때 문제가 생긴다.
언제 발생한 오류인지에로 구별해서 찾는다.
로그순환은 크게 두가지 방식을 사용하는데
기간을 정하거나 용량을 정한다. 보통 날짜가 있는 파일은 기간제이다. (아카이빙한다고함)
숫자가 있는건 어느 개수를 지정하고 순환을 시킨다.

/etc/logroate.conf


suffix 뒤에다 붙이는거
