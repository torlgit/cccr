dns의 계층 구조

dns이전 hosts가 있었고 해당되는 호스트와 아이피를 매핑 해놓은 텍스트 파일이 있었다.
ip 기반이 아닌 이름 기반으로 목적지를 지정했었다.

도메인 주소로 통신할 수 있나? -> 엄밀하게 말하면 없다.
hosts, dns 목적은 문자로된 주소로 아이피로 바꿔주는거고
아이피를 가지고 통신하기 때문에 아이피 목적지 주소가 필요하기 때문에 아이피로 통신해야한다.

dns 서버가 전체 인터넷에 서버를 알고 있지 않다.
dns는 트리형태로 계층구조로 되어있고 분산이 되어있다.
dns hierarchy 라고한다.

맨 위 정점에는
Root Domain이 있고 . 으로  구분한다.
www.google.com. 에서 맨 뒤에 .이 생략 되어있는데 .은 루트 도메인이다.
.은 Root Hint A~M 13개의 서버를 가지고 있다.

Top Level domain (TLD)	
일반적으로 우리가 알고 있는
gTLD 일반적인 탑 레벨 도메인  com, net, org, edu
google, naver	| daum	|	wikipedia

ccTLD kr, jp, us, it ...

TLD(3rd level domain) : co, korea..

3rd까지는 반드시 등록이 되야하고 그 아래쪽은 우리가 만들 수 있다.

subdomain : 각 회사가 만들 수 있다.

Hostname : www

10.56.168.192.in-addr.arpa.

arpa :
in-addr
ip6

TLD에 도메인을 등록을 시킨다.

Root domain 계층 구조이다.
TLD	     com		net		org		edu		kr		jp		us		it	...		arpa
SLD	 google	naver		daum		wikipedia			co korea								in-addr	ip6
TLD								korea
Subdomain			support	storage					busan	seoul
hostname     www		www	ftp					www, main www, ftp

Dns서버는 udp 53포트를 사용한다.

컴퓨터에 Dns 서버가 지정 되어있다. 회사에서 사용하는 Dns를 제외하고 isp에서 제공해준다.
회사 같은 경우 자체적으로 구성 되어있는 Dns서버가 있고 없는 경우는 isp에서 제공해준걸 사용한다.

dns서버랑 isp는 관계없다. 요즘 it 회사에서 dns를 제공해주는 회사도 있다. (구글)

dns서버는 리소스 레코드란걸 가지고 있다. (www x.x.x.x, ftp x.x.x.x 같은 예를 RR
아이피와 dns를 매칭해놓은걸 리소스 레코드라고한다.
모든 dns서버는 리소스 레코드를 가지고있다.
dns 서버는 자신보다 하위에 있는 정보만 가지고 있다.
지구 상의 전체 호스트를 가지고 있는게 아니라 분산해서 가지고있다.

cache only dns :
isp가 제공해주는 dns 서버는 가지고 있는 리소스 레코드가 없다.
dns를 쓸 수 있도록 기능만 제공해준다.
	 Q (www.hansole.com)??
client -----> isp dns

루트서버에 com이 어디에 있는지 물어본다.
모든 dns서버는 자신도 클라이언트이다. 다른 서버에 물어보기 때문에
모든 시스템, 클라이언트들은 캐시를 가지고있다. dns 캐시
영구적으로 저장하지 않는다. ttl을 지정해서줌.

isp에서 지정해놓은 dns는 캐시만 가지고 있다.
사람들이 많이 쓰는것은 캐시로 저장되어있다.
dns
dns 서버들은 모르면 root domain에게 물어본다.
dns 서버는 자신이 필요한 정보만 가지고 있기 때문에 다른 정보는 알 수 없다.

재귀커리
클라이언트가 요청을 한걸 완전한 응답이 돌아오는것

순환쿼리
isp업체들은 자기가 모르는건 순환을 한다.

응답에도 2가지가 있다.
권한이 있다라는건 내가 직접 가지고 있는 리소스 레코드를 주는 것 (캐쉬는 해당사항이 없다)
내가 받은 리소스 레코드를 주는걸 권한이 없는 응답이다.

구글의 dns 서버만 권한이 있는 응답을 할 수 있다.

host -v -t A www.google.com 8.8.8.8
퍼블릭 dns 주소이다. - 그게 뭔데? - cache only dns server
구글 리소스 레코드를 가지고 있는 서버가 아니다. 그래서 권한이 없는 응답이다.

내가 수동으로 권한이 있는 응답을 받아내려면?
host -v -t NS google.com 8.8.8.8

host -v -t A ns1.google.com 8.8.8.8

ns1.google.com []

host -v -t A www.google.com 216.238.32.10

클라이언트가 직접 쿼리를 보내는걸 금지한다.
왜 ?	->	재귀 커리를 안 받도록 해야한다. dns 서버의 용량을 늘려야한다. 누가 얼마나 들어올지 모르니까.
기업이 그러면 감당이 안된다. 반복 쿼리만 되게, 순환 커리만 가능하도록 막아둔다.

재귀 커리를 안 받게 세팅을 해야한다. 순환커리로만 응답을 할 수 있게..
재귀 커리를 받아주게 되면 디도스 공격을 받기 쉬워진다.
tcp 는 힘들지만 udp 는 디도스 공격을 받기 좋다. 방식 자체가 없고 단순하게 보내고 받기만 하는 형태이므로
디도스 공격을 받으면 해당 되는 프로토콜을 차단 시키기도 한다.

권한이 없는 응답은 데이터는 정확한 데이터라고 할 수 없다.
권한이 있는 응답은 일반 클라이언트는 받을 수 없지만 권한이 있는 응답은 정확한 데이터라고 할 수 있다.

FQDN을 지리 했을 때 IP를 알려주는걸 정방향조회
A,AAAA

PTR, reverse lookup
회사 내부에서 구현을 하는 경우가 많지 인터넷에서는 하지 않는다.

윈도우 같은 경우 ipconfig/displaydns 명령어를 사용하면 dns cache를 볼 수 있지만
유닉스는 dns cache를 볼 수 있는 명령어가 없다. 어플리케이션 자체에서 dns cache를 사용한다.

윈도우는 인터넷 브라우저를 띄우면 운영체제 레벨에서 캐시를 관리하는데
유닉스는 어플케이션 자체에서 캐시를 관리한다.

캐시를 관리하는 기법 자체가 다르다.

SOA 권한의 시작.. 권한에 있는 응답과 똑같은 의미이다.
리눅스 계열은 hosts 명령어는 무조건있다.
nslookup은 원래 윈도우에만 존재하는 명령어 였지만 유닉스 계열로 가지고 왔다. (잘 안쓴다)
dic 과 hosts는 다를게 없다.


Dns 소프트웨어
BIND (오픈소스 / 거의 표준이다), NSD (오픈소스)

패키지를 항상 설치하면 설정파일을 확인해야한다.

dns라는 프로토콜은 상당히 복잡한 매커니즘을 가지고있다.
bind 원서가 따로 존재한다. (dns만 약 2000페이지 정도)
;도 주석이다.	//도 주석으로 사용
directory는  /var/named 리소스 레코드 데이터베이스는 기본적으로 /var/named에 있다.
allow-query - 쿼리를 허용할 위치

systemctl enable []

영역(zone)
하나의 도메인은 하나의 영역으로 만들어야한다.

named.conf 파일에 zone (영역)을 설정해야한다.
a~m서버의 정보가 들어있다.
자기가 모르는걸 루트 힌트 서버를 만들어야한다.
모든 dns 서버는 루트 힌트 서버에 정보를 가지고 있어야한다.
패키지 설치 시 기본적으로 존재한다.

일반적으로 도메인명.zone으로 붙인다.	/	cccr.net.zone

/var/named/cccr.net.zone

TTL 3H : 도메인의 수명을 의미 (3시간 / 지정할 수 있다)
@ : 서비스할 영역 도메인 이름의 의미 @ 기호는 origin을 의미한다.
in : internet을 의미
soa : 하나의 존에는 권한의 시작인 soa가 와야한다.	/	도메인 당 하나씩만 있을 수 있다. (무조건)
@ : 네임서버의 주소, dns의 주소
dns 관리자의 메일 주소	@ 대신 .을 써야한다.
( 뒤부터 시리얼 번호 - 하의 레코드 구조

chgrp named cccr.net.zone (그룹권한을 준다)
dns에서는 끝에 점을 붙여야한다.

dns Round
똑같은 기능을 하는 여러 호스트를 두고 (l4 스위치 목적 로드 밸런스 : 균형있게 트래픽을 제공)
dns에서 번갈아가면서 가르쳐주면 분산이 일어날 수 있다.

우리는 호스트를 안 쓰고 도메인만Tmsmsep dho wjqthrdl ehlfRK?
디폴트 호스트 앞에 특정 호스트를 지정하지 않는다. / 디폴트 호스트는 회사의 메인 페이지를 걸어놓는다.
웹서버가 아닌 DNS에서 설정이 가능하다.

mail1	IN	A	10.0.2.30
@	IN	MX	10 10.0.2.30
@는 도메인, 숫자로 우선순위를 줬다.

zone transfer
가용성, 고가용성 모든 것들은 이중화한다.
dns 서버도 이중화할 필요성 있다. 2대씩 제공해준다. dns 한대가 고장이나면 dns를 못하게 되니까.
두대를 구축하는게 좋은데, 둘을 따로따로 관리하는건 쉽지않다. 그래서 하나를 master를 두고 하나는 slave를 둔다.
영역 전송이란건 dns를 마스터, 슬레이브로 이중화 구성을 하는거다.
primary secondary

마스터는 rw가 가능하지만 슬레이브는 r만 가능하다.
master -> slave로 복제를 한다. 영역 파일을 복제하기 위함이다 따로따로 관리할 필요가 없다.
클라이언트는 dns를 줄 때 쌍으로 구성되있는걸 dns1. dns2로 구성한다.
기본은 udp 53으로 물어본다. 무조건 udp만 쓸까? dns는 무조건 udp 53번만 써야한다라고 정해놓은게 없다.
웹은 신뢰성을 담보로 해서 tcp를 쓰는거고 dns는 정보를 빠르게 받기 위해서 upd를 쓴다.
응답을 할 데이터가가 많아지면 udp로 전송을 하면 깨지고 손실될 가능성이 있다.
응답은 udp, tcp에서 골라서 사용한다. 복제는 tcp, udp 53번을 사용한다.

dns 는  tcp, udp 구분 없이 사용하는 프로토콜 중 하나이다.

zon.file.org
