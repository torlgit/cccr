기본적으로 아이피가 바뀐다면 dns가 바뀐 아이피를 확인해서 dns를 등록해야한다.
마지막에 ddns 얘기를 했지만, 기본적으로 아이피가 바꾼다는건 관리자가 작업해야할 내용이 많아진다.

rarp, icmp, bootp

bootp, dhcp는 헤더가 거의 똑같다. 그래서 호환이 된다.
dhcp는 기본적으로 아이피를 임대를 한다라고함.

dhcp가 임대를 할 때 사용하는 패킷 4가지
discovery
offer
request
acknowledge

dhcp 서버가 여러대 있을 수 있다. 고가용성을 지원을 한다.
여러 dhcp 중 특정 서버 udp는 먼저 온게 우선순위가 있다.
먼저 온 dhcp로 부터request 요청을 하게 된다. dhcp 서버는 확인으로 acknowledge를 준다.
ip, client mac 주소를 저장해놓는다. 클라이언트는 acknowledge 메시지를 받으면 아이피를 받게된다.

임대기간이 만료되기전에 갱신, 컴퓨터가 꺼지게 된다면 상관없다.
그전에 임대기간이 만료되기전에 갱신이 되도록 설정이 되어있다.
시스템이 계속 켜져 있는다면 임대 갱신을 하고 dhcp request, dhcp acknowledge를 통해 갱신을 하게된다.

시스템이 종료가 되거나, 네트워크 서비스를 종료를 하게 된다면 임대를 해제를 하는 메시지를 보내게된다.
그걸 dhcp release 라고한다. 못 보내면 DB에는 임대하고 있다라고 남는다.
요청을 하게 되면 똑같은 아이피를 준다.

DHCP 서버 구성
어떤 서비스들은 기본적으로 패키지를 설치를 해야하고, 물론 설치되어 있는 패키지도 있다.
관련되어있는 패키지, 서비스 이름이 다를 수 있다. 어떤 서비스명인지 확인을 해야한다.
enable하기전에 설정 파일을 확인해야한다.

RPM command를 해서 설치된 설정 파일 등을 미리 확인 할 수 있다.
아니면 yum info로 해당되는 패키지의 설정 파일, 어떤 파일을 필요로 하는지 정보를 수집할 수 있다.
해당되는 서비스가 어떤 서비스를 필요로하는지, bind는 /var/named/zonefile 이라던지..
/var/log/message에 로그가 잘 나온다. 로그를 보는걸 생활화하자.

tail -f (스타트 리로드 하기 전에 메시지, 로그 실시간으로 찍어놓고 스타트, 리스타트, 어떤 메시지가 발생하는지
확인을 꼼꼼하게 해야한다)	/	 대부분의 서비스는 이런 순서, 절차로 진행된다.

selinux 정책, 포트, 파일 정책에 따라 문제가 될 수 있다. 로그에 나오기 때문에 로그를 보고 해결할 수 있어야한다.

dhcp 구성을 하기 위한 소프트웨어는 여러가지가 있다.

server1가 dhcp 서버가 될 예정. desktop ip는 동적으로 하는 구성으로 한다.
/etc/dhcp/dhcpd.conf 	/	 dhcpd.conf 설정파일.

dhcp protocol header
ip, gateway [ 클라이언트가 설정할 수 있는 영역]	/ options에 있어야한다.
bootp는 options 부분이 없다. 옵션이라고 붙어있는건 클라이언트한테 제공할 추가적인 내용

dhcpd.conf
맨 위 사용하는 옵션은 글로벌 옵션
아래쪽 상관없이 공통적으로 적용할 옵션	/	아래쪽 구성은 서브넷에 대한 구성

broadcast로 ip로 설정하는 경우는 드물다.

dhcp 예약, dhcp는 사실은 기본적으로 어떤 ip를 받아갈지 클라이언트는 알 수 없다.
dhcp 예약은 클라이언트이긴 하지만 정해진 ip를 할당하기 위한 dhcp예약이다.
mac주소를 지정하면 fqdn에 대한 id a 레코드가 있어야한다.
dhcp reserved라고 한다.	/	패킷트레이서에는 기능이 없지만 실제 라우터에는 존재하는 기능이다.

var/lib/dhcpd/dhcpd.leases
누가 dhcp를 할당 받았는지 알 수 있다.

desktop system이 ip를 자동할당 받게 설정.
100~120번 까지만 dhcp client가 사용할 수 있도록 구성하세요

정방향, 역방향 데스크탑에 관련된건 지우자

ddns 정, 역방향 allow-update [ dhcp 주소; ];
any로 하게 되면 최악이다.

tsig 패킷에 대한 서명.
서명된것만 업데이트	/	 공개키 암호화

dnsset-keygen
	-a : 서명 알고리즘 / hmac 형태를 많이 사용한다. / Hash message authentication code - 메시지 인증코드
	-b : 키에 대한 bit를 지정

	host. domain 이름 쓰면됨



인증은 로컬인증, 원격인증이 있다.
개별적인 커널이 인증을 처리한다. 클라이언트, 서버가 여러대가 되면 인증을 각 개별 시스템이 따로따로 로컬인증을 하게되면 계정, 패스워드, 그룹 관리 할 때 상당히 많은 작업을 해야한다.
시스템마다 개별 인증을 해줘야해서 그래서 원격인증을 한다.

서버는 일반적으로 티켓 또는 웹이나 인터넷에서는 토큰 이라고 얘기한다.	/	비슷한개념
다른 시스템에 접근하거나 내 시스템에 접근할때 인증을 또 받는게 아니라 티켓, 토큰을 보여주고 사용자를 확인 한 후 인증을 할 수 있게 해준다.	/	통합인증개념

sso (single sign on)
원격 인증서버에 한번 인증을 받게되면 티켓을 부여받게되고 티켓을 제시함으로써 권한이 있는 사용자인지 확인받는다.
매번 인증을 받을 필요가 없는 형태

계정정보, 인증정보를 받을 수 있는 서버가 필요하다. (같은 시스템에 서비스 개념으로 나뉠수도 있고, 떨어져 있을 수 있다)

계정 정보 :
directory service (NIS NIS+ LDAP)
현재는 LDAP만 사용을 한다. 하지만 디렉토리 서비스로 자주 나온다고 한다.

DAP ->	LDAP (Lightweight Diretory Access Protocol)	/ DAP의 경량화 버전이다.	| X.500 표준.
x.509v(인증서), 암호화 키를 담을 수 있다.


인증 정보 : 
kerberos (커버로스), 인증 프로토콜

		<--------- 티켓
Client	----------------------------- 계정,인증 server
	 kerbers, LDAPS ---------->

두 가지로 묶어서 쓰는게 => MS Active Diretory	/	FreeIPA

DNS 인증서를 관리해주는 인증서 서버.

인증 정보를 전달 할때 현재 시스템의 시간정보를 저장을 한다. 시간이 맞지 않으면 저장이 안된다.
NTP도 탑재하고 있다.

디렉토리 서비스 : 389 Directory server (LDAP 을 서비스 하는 포트)
인증 서비스 : MIT Kberberos KDC (키 인증 센터)
인증서 관리 : Dogtag (인증서를 관리해주는 서버)
DNS 서비스 : BIND
웹 인터페이스 : Apache, python

를 합친게 freeIPA이다.

디스크의 파일시스템에 있는 디렉토리 형태, 디렉토리는 분류를 하기 위한 목적
지역, 부서, 팀 조직 구성 단위를 분류를 하는걸 디렉토리 서비스라고 한다.
계정을 디렉토리 형태로 만들어서 분류를 시킬 수 있다. 그게 LDAP의 목적이다.
PASSWD, SSH KEY 등 디렉토리 서비스에다가 분류를 해서 만든다.

최상위는 항상 도메인이 있어야한다.
DC(Domain Coponent) : 도메인 구성 요소 	ldap dn / 계층적으로 만든다.
OU(Orgamization Unit) : 조직 구성 단위.
 
오브젝트를 분리해서 디렉토리 서비스라고 한다.

LDAP DN 지리를 하고 인증을 받는다. 역순으로 사용한다.
UID=user1, ou=edm, dc=nobreak, dc=co, dc=kr

리소스를 오브젝트를 가르키는 형식.

커버로스 유닉스 계열에서 아주 널리 사용되고 있는 인증프로토콜
커버로스와 같은 서버를 분류를 하는데 AAA 서버라고 한다.
Authentication, Aithprozation, Acountting 라고한다.

AS (Authentication) : 티켓을 최종적으로 발행하는 서버

TGT : 티켓 발급 서버

TGS : 사용자, 호스트, 시스템이 인증 받을 수 있고 시스템의 서비스가 인증 받을 수 있다.

티켓 : 인증을 받은 키 파일
키탭 : 발급받은 인증키, 인증 받을 수 있는 서비스 목록 /etc/krb5.keytab

키 : 암호화 할 때 사용하는 키

KDC : 분배를 해주는 서버. 

주체(PRICIPAL) : 인증을 받기 위한 주체, 사용자, 호스트가 주체 일수도 있다.
주체가 서비스일 경우 서비스 명, / HOST이름@REALM

Kinit : 명령어

Realm (영역)

통합인증 : 개별인증을 하는게 아니라 통합서버에 인증해서 토큰 사용, 패스
