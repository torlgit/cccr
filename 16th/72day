쿠버네티스는 파드를 외부를 노출시키는 포트포워드를 이용해 외부로 노출 시켰다. (임시 테스트 용도) / kubectl expose
실제 서비스, 외부 노출은 이런 방식을 이용하지 않는다.
내부 통신 - 내부 통신 내부 - 외부 통신 리소스 오브젝트를 사용한다. (서비스 = 포트포워딩을 해준다)
어떤 컨테이너가 서비스를 하는 경우, container의 ip를 클라이언트는 알 수 없다.
dhcp로 할당받고, 그 아이피는 알 수 없다. static하게 줄 수 없다. 서비스 리소스를 이용해서 파드랑 통신을한다.
내부통신, 외부통신 다 서비스를 이용한다. 서비스를 삭제하기 전까지 아이피는 동일하다

애드온
쿠버네티스에서 공식, 비공식적으로 지원한다.

주요 기능 
클러스터 DNS : 클러스터 내에서 작동하는 dns (외부에서 접근하기 위해 사용하는 dns가 아닌 내부에서만 사용하는 dns)
서비스를 생성하면 특정한 FQDN이 붙는다. pods와 service는 fqdn을 통해서 통신을한다.
파드와 서비스의 연결관계는 셀렉터를 이용한다.

고정된 fqdn으로 dns를 얻어올 수 있다.

대시보드 : 웹 인터페이스, yaml을 이용해서 해야한다.

컨테이너 리소스 모니터링 : pods의 리소스 사용량을 체크해준다. 힙스터 프로젝트 (개발되지 않는다)
모니터링을 하기 위해서, 쿠버네티스에서 제공하는 모니터링툴을 이용할 수 없고, 프로메테우스를 사용한다.

클러스터 로깅 : 기본적으로 로컬에 로그를 남기게되고, 통합 하기 위해선 ELK라는 서비스를 사용한다.

서비스라고 하는건 내부, 외부에서 접근하기 위한 포트포워딩을 하는 기능이다.
pods의 ip를 알 수 없기 때문에, 알 수는 있지만 굉장히 번거롭다.

클러스터의 Ip = service의 Ip
cluster-ip는 내부통신이기 때문에 인스턴스의 아이피가 부여되지만 그 아이피로 통신할 수 없는거와 같다.
service는 로드밸런스를 구성할 필요가없다. 서비스에서 로드밸런스를 해주기 때문이다.

인증, 처리는 웹 서버가 할 수 없다. = Was가 처리함
어플리케이션 서버를 항상 똑같은 어플리케이션 서버를 사용할 수 있게 해준다.

was가 여러 개 있을 때 인증을 받게되면 해당되는 특정 Was만 가능하다.
해당되는 Was에서만 요청과 응답을 해야한다. (똑같은 pod에 연결해줘야 한다) / 세션 친화성을 구현해줘야함.
리눅스에서 하려면 굉장히 많은 설정을 필요로 요함 / 요청을 하게되면 똑같은 아이피만 나와야한다.

coredns-5c98db65d4-lz75w
coredns-5c98db65d4-w5pq5
kubedns

kubectl get  svc kube-dns -o yaml -n kube-system
환경변수 env를 이용해서 서비스의 포트를 알 수 있다.
크게 두 가지 방법으로 서비스를 찾을 수 있다 (해당되는 파드로 접근할 수 있는 주소를 얻는다는걸 의미한다)
환경변수, dns 지리를 해서 서비스를 찾을 수 있다.

환경변수보다 내부 kubedns가 있는 경우 dns로 지리하는 경우가 훨씬 쉽다. 어플리케이션에 다른 pod로 접근이 가능하다.

kubectl run nettool -it --image=praqma/network-multitool --generator=run-pod/v1 --rm -n test2 bash
curl cccr.default (default namespace)
host cccr.default

clusterip : 
hostport = 사용하지 않는다. minikube는 단일 노드

인그레스
에드온 기능? kubeadm은 없다.
인그레스는 서비스를 외부에 노출 시키는 리소스이다. 
fqdn을 이용해서 인그레스 컨트롤러가 해당되는 서비스를 연결 시켜준다. (인그레스 컨트롤러 아이피가 있다)
클라이언트는 단일 지점을 접근을 하게된다. (인그레스로) 
사용자마다 서비스마다 별도의 서비스를 따로 따로 알려줄 필요가 없다. 클라이언트는 인그레스 컨트롤러로 접속하면된다.

인그레스는 사용자가 요청한 주소를 보고 어떤 서비스를 할지 결정을한다.
인그레스는 아이피를 가지고 통신하지 못한다. (HOSTS로 통신해야함) | DNS가 필요로함. 
DNS없이 하는 방법은 두 가지 있다.
1. /etc/hosts
2. curl로 정의

TLS 프록시
end to end 암호화 (종단간의 암호화) 중간에서 스니핑을 하더라도 알 수 없다.
클라이언트에 시작점부터 끝점까지 엔드 투 엔드 종단간에 암호화가 이루어진다.
종단간의 암호화가 좋은데

기본적인 네트워크는 내부와 외부를 격리시키기 위해서 여러가지 장비가 존재한다.
침입 방지 시스템, 안티 스팸, 안티 디도스 여러 가지 수많은 장비가 있다.
암호화 통신을 하게되면 공격인지 아닌지 알 수 있나? 알 수 있는 방법이 없다.
보안 때문에 암호화를 사용하는데 암호화 때문에 보안이 무방비가 되는거다. 방법이 없다.
일부분 경로까지만 tls를 사용한다.

보통은 이 기능은 loadbalancer가 가지고있다.
로드 밸런스와 클라이언트까지는 암호화가 되고 그 뒤에는 암호화를 푼다.
문제는 실제로 클라이언트는 웹 서버와 통신한다. (tls는 로드밸런스 까지만 이루어져야함)
nginx tls 터미네이션 구현. aws, elb도 이 기능이 존재한다. (nginx만 되는게 아니라 가장 방법이 간단하다)

openssl, 

라이브 프로브 : 작동하는지 안하는지 확인하ㅗ

레디니스 프로브 : 실제로 레디가 됐을 때 kubectl get pods (Ready 0/1 -> 1/1)
Ready가 되었는지 확인하고 체크를 해준다.

라이브니스 프로브와 레디니스 프로브는 항상 존재해야한다.

Ready 되는것과 안되는것의 차이가 있나?
말 그대로 준비가 된 파드만 엔드포인트에 등록을 시킨다.
어플리케이션이 준비가 되지도 않았는데 레디니스 프로브를 사용하지 않으면 어플리케이션에 실제 가동여부와 상관없이 등록 시킨다.
엔드포인트에 등록할 포인트를 정한다. 준비가 된 파드만 엔드포인트에 등록 시킨다.


오늘의 정리

서비스는 크게 두 가지 내부와 외부
내부는 클러스트 ip
외부는 호스트포트, 로드밸런스, 노드포트(온프레미스에서 사용)
퍼블릭 클라우드에서도 노드로 만드는게 이점이 있다.
로드밸런스 아이피를 이용해서 클라이언트 접근 (인그레스를 붙여서 분산시켜준다) / 클라이언트 dns가 필요로함
경로까진 줄 수 없다. (Curl이 이점이 있다)

레디니스, 준비가 되었는지, (엔드포인트 등록 여부로 사용) 작동할 준비가 되어야 접근이 가능하다. 레디가 안된 경우가 엔드포인트 등록을 하지 않음으로써 


특정 파드를 분리해서 구별해서 헤드리스 서비스 서비스의 클러스트 아이피를 부여하지 않는 방법으로
파드에 아이피에 직접 접속할 수 있게 만든다.
